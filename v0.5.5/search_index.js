var documenterSearchIndex = {"docs":
[{"location":"api/control/","page":"Control operations","title":"Control operations","text":"using GRUtils, Random\nRandom.seed!(111)","category":"page"},{"location":"api/control/#Control-operations","page":"Control operations","title":"Control operations","text":"","category":"section"},{"location":"api/control/#Figures-and-plots-initialization/referencing","page":"Control operations","title":"Figures and plots initialization/referencing","text":"","category":"section"},{"location":"api/control/","page":"Control operations","title":"Control operations","text":"Figure(::Any, ::String)\ngcf\ncurrentplot","category":"page"},{"location":"api/control/#GRUtils.Figure-Tuple{Any,String}","page":"Control operations","title":"GRUtils.Figure","text":"Figure([figsize::Tuple{Float64, Float64}, units::String])\n\nCreate a new figure of a given size.\n\nThe figure size is defined by figsize (a 2-tuple with the target width and height), and units (a string with the abbreviation of the units: \"px\" for pixels, \"in\" for inches, \"cm\" for centimeters or \"m\" for meters). The default dimensions used by Figure() with no arguments is 600×450 pixels — or a proportional increased size, if the detected display resolution is high. This constructor also sets the \"current figure\" to the one that has just been created..\n\n\n\n\n\n","category":"method"},{"location":"api/control/#GRUtils.gcf","page":"Control operations","title":"GRUtils.gcf","text":"gcf()\ngcf(fig::Figure)\n\nGet the global current figure, or set it to be fig.\n\n\n\n\n\n","category":"function"},{"location":"api/control/#GRUtils.currentplot","page":"Control operations","title":"GRUtils.currentplot","text":"currentplot([fig::Figure])\n\nGet the \"current plot\", i.e. the target of the next plotting operations in the (optionally) given figure fig.\n\nIf no figure is given, the \"current figure\" is used (cf. gcf).\n\n\n\n\n\n","category":"function"},{"location":"api/control/#Multiple-plots","page":"Control operations","title":"Multiple plots","text":"","category":"section"},{"location":"api/control/","page":"Control operations","title":"Control operations","text":"hold\nsubplot","category":"page"},{"location":"api/control/#GRUtils.hold","page":"Control operations","title":"GRUtils.hold","text":"hold(flag::Bool)\n\nSet the hold flag for combining multiple plots.\n\nhold(true) prevents clearing previous plots, so that next plots will be drawn on top of the previous one until hold(false) is called.\n\nUse the keyword argument hold=<true/false> in plotting functions, to set the hold flag during the creation of plots.\n\n\n\n\n\n","category":"function"},{"location":"api/control/#GRUtils.subplot","page":"Control operations","title":"GRUtils.subplot","text":"subplot(num_rows, num_columns, indices[, replace])\n\nSet a subplot in the current figure.\n\nBy default, the current plot covers the whole window. To display more than one plot, the window can be split into a number of rows and columns, with each plot covering one or more cells in the resulting grid.\n\nSubplot indices are one-based and start at the upper left corner, with a new row starting after every num_cols subplots.\n\nThe arguments num_rows and num_cols indicate the number of rows and columns of the grid of plots into which the figure is meant to be divided, and indices is an integer or a collection of integers that identify a group of cells in that grid. This function returns a plot with the minimum size that spans over all those cells, and appends it to the array of plots of the figure, such that it becomes its current plot.\n\nIf the viewport of the new subplot coincides with the viewport of an existing plot, by default the older one is moved to the first plane, and taken as the \"current plot\"; but if there is only a partial overlap between the new subplot and other plots, the overlapping plots are removed. To override this behavior and keep all previous plots without changes, set the optional argument replace to false.\n\nExamples\n\n# Create example data\nx = randn(100_000)\ny = randn(100_000)\n# Draw an hexagonal plot in the bigger bottom-right region\nsubplot(3, 3, (5, 9))\nhexbin(x, y, colorbar = false)\n# Draw marginal histograms\nsubplot(3, 3, (2, 3))\nhistogram(x)\nsubplot(3, 3, (4, 7))\nhistogram(y, horizontal = true, xflip = true)\n# Draw a shade plot in the smaller top-left region\nsubplot(3, 3, 1)\nshade(x, y)\n\n\n\n\n\n\n","category":"function"},{"location":"api/control/","page":"Control operations","title":"Control operations","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/subplot.jl\") # hide","category":"page"},{"location":"api/control/#Animations","page":"Control operations","title":"Animations","text":"","category":"section"},{"location":"api/control/","page":"Control operations","title":"Control operations","text":"video","category":"page"},{"location":"api/control/#GRUtils.video","page":"Control operations","title":"GRUtils.video","text":"video(fun::Function, target=\"webm\")\nvideo(figs::AbstractArray{<:Fig}, target=\"webm\")\n\nMake a video from a function or an array of figures.\n\nThe first argument can be an array of Figures that will be displayed as a sequence of frames in the video, or a function without arguments that draws the figures (normally a loop where the figures are created and drawn one after another). That function can be defined anonymously in the call to video with the do syntax (see the example).\n\nThe second (optional) argument target must be a string with one of the formats \"webm\" (default), \"mp4\" or \"mov\".\n\nThe output is an object that may be displayed as a video of the given format (depending on the supported MIME outputs of the environment). Use videofile to save such a video in a file.\n\nExamples\n\n# Make a plot with example data\nx = LinRange(0, 800, 100)\ny = sind.(x)\nplot(x,y)\n# Make a video sliding over the X axis\nvideo(\"webm\") do\n  for d = 0:10:440\n    xlim(d, d+360)\n    draw(gcf())\n  end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/control/#Save-to-files","page":"Control operations","title":"Save to files","text":"","category":"section"},{"location":"api/control/","page":"Control operations","title":"Control operations","text":"savefig\nvideofile","category":"page"},{"location":"api/control/#GRUtils.savefig","page":"Control operations","title":"GRUtils.savefig","text":"savefig(filename[, fig])\n\nSave a figure to a file.\n\nDraw the current figure in a file of the given name. Which file types are supported depends on the installed workstation types, but GR usually is built with support for .png, .jpg, .pdf, .ps, .gif and various other file formats.\n\nIf no figure is given (optional argument fig), the current figure is used.\n\nExamples\n\n# Create a simple plot\nx = 1:100\nplot(x, 1 ./ (x .+ 1))\n# Save the figure to a file\nsavefig(\"example.png\")\n\n\n\n\n\n","category":"function"},{"location":"api/control/#GRUtils.videofile","page":"Control operations","title":"GRUtils.videofile","text":"videofile(fun::Function, target, overwrite=false)\nvideofile(figs::AbstractArray{<:Fig}, target, overwrite=false)\n\nMake a video from a function or an array of figures and save it into a file.\n\nThe first argument can be an array of Figures that will be displayed as a sequence of frames in the video, or a function without arguments that draws the figures (normally a loop where the figures are created and drawn one after another). That function can be defined anonymously in the call to videofile with the do syntax (see the example).\n\nThe secondargument target must be a string with the name of the video file, whose format is determined by the extension of the file. The supported extensions are \"webm\", \"mp4\" or \"mov\".\n\nUse overwrite=true to force the creation of target if the file already exists (otherwise an error will be thrown in such cases).\n\nExamples\n\n# Make a plot with example data\nx = LinRange(0, 800, 100)\ny = sind.(x)\nplot(x,y)\n# Make a video sliding over the X axis\nvideofile(\"sin.mp4\") do\n  for d = 0:10:440\n    xlim(d, d+360)\n    draw(gcf())\n  end\nend\n\n\n\n\n\n","category":"function"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"CurrentModule = GRUtils","category":"page"},{"location":"internals/createplots/#Creating-plots","page":"Creating plots","title":"Creating plots","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"At the lowest level, a single plot can be created through the following steps:","category":"page"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Define a Viewport with the NDC of the boxes where the plot should be drawn.\nCreate one or more Geometry objects based on the data that should be plotted and the kind of geometries that will represent them, and collect them in a vector.\nCreate an Axes object with suitable dimensions and properties to contain the geometries.\nCreate a Legend to display the legends, if suitable.\nCreate a Colorbar to represent a guide to color codes, if suitable.\nPut all the previous components together in a PlotObject.\nTake a Figure where the plot should be displayed —; e.g. the current figure through gcf(), or create it, and put the newly created PlotObject into the plots vector of that figure.","category":"page"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"GRUtils also provides various constructors of those types and other functions that make those steps easier.","category":"page"},{"location":"internals/createplots/#Viewport-constructors","page":"Creating plots","title":"Viewport constructors","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Viewport(::Any, ::Bool)","category":"page"},{"location":"internals/createplots/#GRUtils.Viewport-Tuple{Any,Bool}","page":"Creating plots","title":"GRUtils.Viewport","text":"Viewport(subplot, frame::Bool [, ratio::Real, margins])\n\nReturn a Viewport object, defined by the normalized coordinates of the box that contains it (the argument subplot, which are normalized with respect to the size of the figure, not the whole device), and a flag (frame::Bool) telling whether there should be a frame. The size of that frame is calculated automatically.\n\nThis constructor also accepts to optional arguments: ratio, which is the width:height ratio of the inner box, and margins, a 4-vector with extra margins that there should be between the outer and inner boxes, in addition to the default size of the frame (in the order left-right-bottom-top).\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/#Geometry-constructors","page":"Creating plots","title":"Geometry constructors","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Geometry(::Symbol)\nGeometry(::Geometry)","category":"page"},{"location":"internals/createplots/#GRUtils.Geometry-Tuple{Symbol}","page":"Creating plots","title":"GRUtils.Geometry","text":"Geometry(kind::Symbol [; kwargs...])\n\nReturn a Geometry with selected parameters given by keyword arguments.\n\nMost geometries do not need data for all the possible parameters that the Geometry type accepts. Thus, to simplify the creation of geometries, an alternative constructor takes the geometry’s kind as the only positional argument, and the rest of fields are given as keyword arguments (empty by default).\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/#GRUtils.Geometry-Tuple{GRUtils.Geometry}","page":"Creating plots","title":"GRUtils.Geometry","text":"Geometry(g::Geometry; kwargs...)\n\nReturn a copy of g replacing the data and attributes given as keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"There is also a function geometries to create vectors of Geometry objects from the input data easily, or to fetch them from an already existing plot, taking advantage of multiple dispatch:","category":"page"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"geometries","category":"page"},{"location":"internals/createplots/#GRUtils.geometries","page":"Creating plots","title":"GRUtils.geometries","text":"geometries(kind, x [, y, z, c; kwargs...]) -> Vector{Geometry}\n\nCreate a vector of Geometry objects of a given kind, from arrays of data that define the coordinates of the geometries. All the other parameters of the geometries are given as keyword arguments\n\nThis function accepts coordinates defined only by one array of numbers, by two variables (x and y, typically for 2-D plots), three (x, y, z) or all four variables (x, y, z and c). If there is only one array x of real numbers given for the geometry coordinates, they will actually be used as Y coordinates, and X will be defined as a sequence of integers starting at 1. If that array contains complex numbers, the real part will be taken as X coordinates, and the imaginary part as Y coordinates.\n\nThe coordinates can be given as vectors or matrices with the same number of rows. In the latter case, each column of the matrices will be used to define a different Geometry. If some coordinates are given as vectors while other are in matrices, vectors will be recycled in all the geometries. E.g. if x is a vector with N numbers and y a matrix with N rows and M columns, the result will be a M-vector of geometries g such that g[i] will be a geometry whose X coordinates are the vector x, and whose Y coordinates are the i-th column of y.\n\nIn addition, the last coordinate can be given as a \"broadcastable\" function that takes the previous coordinates as inputs.\n\n\n\n\n\ngeometries(p::PlotObject)\n\nReturn the vector of geometries contained in p.\n\n\n\n\n\n","category":"function"},{"location":"internals/createplots/#Axes-constructors","page":"Creating plots","title":"Axes constructors","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"There are two alternative constructors for Axes objects: one like the alternative Geometry constructor, which is basically a shortcut to define only the non-empty parameters via keyword arguments; and another one that sets the axes up automatically based on the data to be plotted.","category":"page"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Axes(::Symbol)\nAxes(::Any, ::Array{<:Geometry})","category":"page"},{"location":"internals/createplots/#GRUtils.Axes-Tuple{Symbol}","page":"Creating plots","title":"GRUtils.Axes","text":"Axes(kind::Symbol [; kwargs...])\n\nReturn an Axes object with selected parameters given by keyword arguments.\n\nThis constructor only requires the kind of the axes (:axes2d, :axes3d or :axespolar), such that all the other parameters are passed as keyword arguments. Null or empty values are used by default for the parameters that are not given.\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/#GRUtils.Axes-Tuple{Any,Array{var\"#s17\",N} where N where var\"#s17\"<:GRUtils.Geometry}","page":"Creating plots","title":"GRUtils.Axes","text":"Axes(kind, geoms::Array{<:Geometry} [; kwargs...]) where kind\n\nReturn an Axes object defined by the kind of the axes, and a vector of Geometry objects that are meant to be plotted inside the axes, which are used to calculate the different axis limits, ticks, etc. Keyword arguments are used to override the default calculations.\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/#Legend-constructors","page":"Creating plots","title":"Legend constructors","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Legend(::Array{<:Geometry}, ::Any)","category":"page"},{"location":"internals/createplots/#GRUtils.Legend-Tuple{Array{var\"#s17\",N} where N where var\"#s17\"<:GRUtils.Geometry,Any}","page":"Creating plots","title":"GRUtils.Legend","text":"Legend(geoms, frame [, maxrows])\n\nReturn a Legend object defined by the collection of geometries that are meant to be referred to in the legend (geoms), and the dimensions (width, height) of the frame in which the legend should be drawn.\n\nThe geometries are used to set the number of items to be drawn in the legend, and their labels. The frame is used to estimate the font size of the labels.\n\nOptionally, this constructor can take the maximum number of items that are represented in each column of the legend. Only the items in that collection of geometries where label is not empty will be included.\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/#Colorbar-constructors","page":"Creating plots","title":"Colorbar constructors","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Colorbar(::Axes)","category":"page"},{"location":"internals/createplots/#GRUtils.Colorbar-Tuple{GRUtils.Axes}","page":"Creating plots","title":"GRUtils.Colorbar","text":"Colorbar(axes::Axes [, colors=256])\n\nReturn a Colorbar defined by an Axes object that is used to calculate its different properties, depending on the kind of axis and the range of the c axis. If the c axis is not defined, this will return an empty Colorbar.\n\n\n\n\n\n","category":"method"},{"location":"internals/createplots/#Top-level-plot-constructors","page":"Creating plots","title":"Top-level plot constructors","text":"","category":"section"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"The constructors presented above for the different components of a plot allow to build plots from data using different \"grammars\". Besides, GRUtils also provide top-level Plotting functions that imitate the interface provided by jlgr.","category":"page"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"Since most of those functions follow the same basic steps described above, a macro @plotfunction is provided to create them from a template.","category":"page"},{"location":"internals/createplots/","page":"Creating plots","title":"Creating plots","text":"@plotfunction","category":"page"},{"location":"internals/createplots/#GRUtils.@plotfunction","page":"Creating plots","title":"GRUtils.@plotfunction","text":"@plotfunction(fname, options...)\n\nMacro to create plotting functions. E.g. @plotfunction plot creates two functions:\n\n* `plot!(f::Figure, args...; kwargs...)`\n* `plot(args...; kwargs...)`\n\nThe first of those functions (the one whose name ends with an exclamation) edits the figure given as first argument, replacing its last plot by a new one. The second function (the one without exclamation) creates the plot in the current figure. How those functions work depends on the options that are passed after the function name to the macro. Those options are expressed in the fashion of keyword argments, i.e. as key = value, and they can be the following:\n\ngeom: a Symbol with the name of the kind of the Geometry that is created.\naxes: a Symbol with the name of the kind of the Axes that are created.\nplotkind: a Symbol with the name of the plot kind (only needed as meta-data).   If this option is not given, the name of the function is used by default.\nsetargs: a function that takes the positional and keyword arguments that are   passed to the functions, and returns: (a) a tuple of positional arguments   to be passed to the function geometries), and   (b) the set of keyword arguments that are passed to the constructor of   geometries, axes, and the plot object. If setargs is not defined, the   positional and keyword arguments are returned untransformed.\nkwargs: a named tuple with extra keyword arguments that are passed to   the constructors of geometries, axes and the plot object.\ndocstring: the documentation string that will be assigned to the plotting function.\n\n\n\n\n\n","category":"macro"},{"location":"animations/#Animations-and-videos","page":"Animations","title":"Animations and videos","text":"","category":"section"},{"location":"animations/","page":"Animations","title":"Animations","text":"A sequence of figures can be presented as a video, using the function video – or videofile in order to save it as a file.","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"There are two ways of producing plot animations. The sequence of figures may be stored in an array. For instance, a video that shows a sliding window of the sin function may be created from a collection of figures created like this:","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"figures = Figure[]\nfor d = 0:10:440\n  x = LinRange(d, d+360, 45)\n  y = sind.(x)\n  push!(figures, plot(x, y))\nend","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"The array figures might be then used to produce a video in WebM format as follows:","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"video(figures, \"webm\")         # As a Julia object\nvideofile(figures, \"sin.webm\") # Written in a file","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"The first line of this example creates a video that can be properly displayed if the code is being executed in an environment that supports such kind of content, like IJulia notebooks or other HTML contexts. Otherwise, it may be more convenient to save the animation in a video file, as in the second line of the example. Besides \"webm\", other supported extensions for videos are \"mp4\" and \"mov\".","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"However, storing the figures in an array may consume a lot of memory. So, unless you need to keep the figures for some other reason, it is more efficient to use a function that overwrites the previous figure after drawing it. For instance:","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"function sliding_window()\n  # Make a plot with the full window\n  x = LinRange(0, 800, 100)\n  y = sind.(x)\n  plot(x,y)\n  # Draw the sliding window over the X axis\n  for d = 0:10:440\n    xlim(d, d+360)\n    draw(gcf())\n  end\nend\n\n# Now create the video with that function\nvideofile(sliding_window, \"sin.webm\")\n# or\nvideo(sliding_window, \"webm\")","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"The key in that function is the loop with repeated calls to draw(gcf()). That command is the one that actually produces the graphic representation of the current figure, i.e. draws each frame of the video. When making animations, it is not sufficient to call the function plot that creates the figures; it is necessary to draw them explicitly.","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"Another convenient way of calling the \"function-\" versions of videofile or video is with the do syntax that lets you create anonymous functions \"on the fly\", and pass them silently as the first argument of a function. For instance, the following code produces the animation that is shown next:","category":"page"},{"location":"animations/","page":"Animations","title":"Animations","text":"using GRUtils # hide\nFigure(); # hide\n# Make a plot with example data\nx = LinRange(0, 800, 100)\ny = sind.(x)\nplot(x,y)\n# Make a video sliding over the X axis\nvideo(\"webm\") do\n  for d = 0:10:440\n    xlim(d, d+360)\n    draw(gcf())\n  end\nend","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"using GRUtils, Random\nRandom.seed!(111)","category":"page"},{"location":"multiple/#Working-with-multiple-plots","page":"Multiple plots","title":"Working with multiple plots","text":"","category":"section"},{"location":"multiple/#Figures","page":"Multiple plots","title":"Figures","text":"","category":"section"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"GRUtils stores the data generated in the creation of plots in objects of the type Figure. There is a global \"current figure\" that is silently used by all the basic functions to create, modify and save plots. New figures can be created with the Figure constructor, which in its simplest form is just a call to Figure().","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"As all Julia objects, figures can be assigned to variables, a useful resource to work with different figures. The current figure can be retrieved with the function gcf() – standing for \"get current figure\", and is also returned by plotting functions like plot. On the other hand, a figure that is stored in the variable fig can be made the current figure by gcf(fig).","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"Most functions to work with plots in GRUtils have methods or variants that allow to specify what figure will be used. For instance, all plotting functions (e.g. plot, scatter, histogram, etc.) have \"in-place\" versions whose name end with an exclamation mark (i.e. plot!, scatter!, histogram!...). The first argument of those functions is the Figure object where the plot will be created. Let's see an example:","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"plot(x, y)       # creates a plot in the current figure\nfig = gcf()      # assigns the current figure to `fig`\nfig2 = Figure()  # now `gcf()` will refer to `fig2`\nplot(x, z)       # this is plotted `fig2`\nplot!(fig, x, z) # draws the same plot in `fig`\ngcf(fig)         # now `gcf()` will refer to `fig` again","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"To save a particular figure in an image file, give the variable that contains the figure as second argument to the function savefig, i.e. savefig(filename, fig).","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"Some programming environments may provide only one graphic device, but you can still work with various figures, although only one can be seen at the same time. To show again a figure that might have been replaced by another on the display, you just have to \"call\" it, or explicitly use the display function on it, like this:","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"# `fìg` is a figure with a plot to be shown\nfig\ndisplay(fig)  # Normally the same as just calling `fig`","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"This action also comes in handy to update the visualization of a figure that might have been modified after its creation.","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"On the other hand, show(fig) will normally show the textual representation of the figure on the screen.","category":"page"},{"location":"multiple/#Subplots","page":"Multiple plots","title":"Subplots","text":"","category":"section"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"A figure can contain one or various plots, arranged in a flexible layout. The individual plots are stored in objects of the type PlotObject; all the plots of a figure referred to by the variable fig are collected in the array fig.plots. Normally, plotting operations are applied to the last \"subplot\", which can be retrieved by the function currentplot(::Figure). Without arguments, that function returns the current plot of the current figure.","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"The function subplot can be used to split the current figure into a grid of plots, and define a \"subplot\" that covers one or more cells of that grid.","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"Subplots can be created for specific figures with the \"in-place\" function subplot!, which differs from subplot in that it takes the figure as first argument.","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"The functions that set the Plot attributes also have in-place versions (e.g. title!, legend!, etc.), whose first argument is the figure or the specific plot whose attributes are meant to be modified. For instance:","category":"page"},{"location":"multiple/","page":"Multiple plots","title":"Multiple plots","text":"# Example data\nx = 1:20\ny = randn(20)\nz = exp.(y) .+ randn(20)\nleftplot = subplot(1,2,1)\nplot(x, y)     # Line plot on the left hand side\nrightplot = subplot(1,2,2)\nscatter(y, z)  # Scatter plot to the right hand side\n\nfig = gcf()\ntitle!(fig, \"Nice plot\")         # Same as `title(\"Nice plot\")`\ntitle!(leftplot, \"First plot\")  # Set the title of the first plot\nfig   # The function `title!` does not update the visualization","category":"page"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"using GRUtils, Random\nRandom.seed!(111)","category":"page"},{"location":"api/attributes/#Plot-attributes","page":"Plot attributes","title":"Plot attributes","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"The following functions can be used to modify existing plots, adding titles and other textual guides, changing their dimensions, colors, etc.","category":"page"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"The majority of those attributes can also be defined at the time of the creation of the plot, adding a keyword argument with the name of the corresponding function and the value of its argument, e.g. plot(x, y, grid=false). That option is commented in the descriptions of the functions that support it.","category":"page"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"tip: Texts with LaTeX expressions\nAttributes with text like titles, axis guides and legends accept strings with UTF-8 characters and LaTeX expressions. The package LaTeXStrings can be used to reduce the burden of writing escape sequences in LaTeX expressions.","category":"page"},{"location":"api/attributes/#Titles","page":"Plot attributes","title":"Titles","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"title","category":"page"},{"location":"api/attributes/#GRUtils.title","page":"Plot attributes","title":"GRUtils.title","text":"title(s)\n\nSet the plot title as the string s.\n\nUse the keyword argument title=s in plotting functions, to set the title during the creation of plots.\n\nExamples\n\n# Set the plot title to \"Example Plot\"\ntitle(\"Example Plot\")\n# Clear the plot title\ntitle(\"\")\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#Axis-guides","page":"Plot attributes","title":"Axis guides","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"grid\nxlabel\nxticks\nxticklabels","category":"page"},{"location":"api/attributes/#GRUtils.grid","page":"Plot attributes","title":"GRUtils.grid","text":"grid(flag::Bool)\n\nDraw or disable the grid of the current plot axes.\n\nUse the keyword argument grid=<true/false>, etc. in plotting functions, to set the grid during the creation of plots.\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.xlabel","page":"Plot attributes","title":"GRUtils.xlabel","text":"xlabel(s)\nylabel(s)\nzlabel(s)\n\nSet the X, Y or Z axis labels as the string s.\n\nUse the keyword argument xlab=s, etc. in plotting functions, to set the axis labels during the creation of plots.\n\nExamples\n\n# Set the x-axis label to \"x\"\nxlabel(\"x\")\n# Clear the y-axis label\nylabel(\"\")\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.xticks","page":"Plot attributes","title":"GRUtils.xticks","text":"xticks(minor[, major = 1])\nyticks(minor[, major = 1])\nzticks(minor[, major = 1])\n\nSet the minorintervals of the ticks for the X, Y or Z axis, and (optionally) the number of minor ticks between major ticks.\n\nUse the keyword argument xticks=(minor, major), etc. in plotting functions, to set the tick intervals during the creation of plots (both the minor and major values are required in this case).\n\nExamples\n\n# Minor ticks every 0.2 units in the X axis\nxticks(0.2)\n# Major ticks every 1 unit (5 minor ticks) in the Y axis\nyticks(0.2, 5)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.xticklabels","page":"Plot attributes","title":"GRUtils.xticklabels","text":"xticklabels(f)\nyticklabels(f)\n\nCustomize the string of the X and Y axes tick labels.\n\nThe labels of the tick axis can be defined by a function with one argument (the numeric value of the tick position) that returns a string, or by an array of strings that are located sequentially at X = 1, 2, etc.\n\nUse the keyword argument xticklabels=s, etc. in plotting functions, to set the axis tick labels during the creation of plots.\n\nExamples\n\n# Label the range (0-1) of the Y-axis as percent values\nyticklabels(p -> Base.Printf.@sprintf(\"%0.0f%%\", 100p))\n# Label the X-axis with a sequence of strings\nxticklabels([\"first\", \"second\", \"third\"])\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#Axis-dimensions","page":"Plot attributes","title":"Axis dimensions","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"xlim\naspectratio\nzoom\npanzoom","category":"page"},{"location":"api/attributes/#GRUtils.xlim","page":"Plot attributes","title":"GRUtils.xlim","text":"xlim(inf, sup [, adjust::Bool = false])\nxlim((inf, sup), ...)\nylim(inf, sup, ...)\nylim((inf, sup), ...)\nzlim(inf, sup, ...)\nzlim((inf, sup), ...)\n\nSet the limits for the plot axes.\n\nThe axis limits can either be passed as individual arguments or as a tuple of (inf, sup) values. Setting either limit to nothing will cause it to be automatically determined based on the data, which is the default behavior.\n\nAdditionally to the limits, the flag adjust can be used to tell whether or not the limits have to be adjusted.\n\nUse the keyword argument xlim=(inf, sup), etc. in plotting functions, to set the axis limits during the creation of plots.\n\nExamples\n\n# Set the x-axis limits to -1 and 1\nxlim((-1, 1))\n# Reset the x-axis limits to be determined automatically\nxlim()\n# Set the y-axis upper limit and set the lower limit to 0\nylim((0, nothing))\n# Reset the y-axis lower limit and set the upper limit to 1\nylim((nothing, 1))\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.aspectratio","page":"Plot attributes","title":"GRUtils.aspectratio","text":"aspectratio(r)\n\nSet the aspect of the current plot to a given width : height ratio.\n\nUse the keyword argument aspectratio=r, etc. in plotting functions, to set the aspect ratio during the creation of plots.\n\nExamples\n\n# Create example data\nx = LinRange(-2, 2, 40)\ny = x.^3 .+ x.^2 .+ x\n# Draw a plot with panoramic ratio (16:9)\nplot(x, y)\naspectratio(16/9)\n\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.zoom","page":"Plot attributes","title":"GRUtils.zoom","text":"zoom(r)\n\nZoom the plot by the ratio indicated by r.\n\nIn two-dimensional plots, the \"zoomed\" axes are centered around the same point, but proportionally resized to r times the original size.\n\nIn three-dimensional scenes defined with \"camera\" settings (e.g. in isosurface plots), the camera distance is divided by r.\n\nExamples\n\n# Reduce the axes to half their size\nzoom(0.5)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.panzoom","page":"Plot attributes","title":"GRUtils.panzoom","text":"panzoom(x, y[, s = 0])\n\nPan/zoom the axes of the current plot.\n\nThe focus of the zoom is set at a point with an offset of (x, y) units in normalized device coordinates (NDC) from the center of the current axes. The corners of the axes are linearly displaced towards that point, such that the size of the new axes is s times their original size.\n\nIf s is set to 0 (the default value), the center of the axes is displaced at the focus, without resizing-\n\nExample\n\n# Move the center 1 unit right and 0.2 up (NDC)\npanzoom(1, 0.2)\n# Reduce the focus of the axes to half their size\n# focusing on the previous point\npanzoom(1, 0.2, 0.5)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#D-views","page":"Plot attributes","title":"3-D views","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"viewpoint\nrotate\ntilt\nmovefocus\nturncamera","category":"page"},{"location":"api/attributes/#GRUtils.viewpoint","page":"Plot attributes","title":"GRUtils.viewpoint","text":"viewpoint(rotation, tilt)\n\nSet the viewpoint of three-dimensional plots.\n\nrotation and tilt must be integer values that indicate the \"azimuth\" and \"elevation\" angles of the line of sight (in degrees).\n\nIf both angles are zero, the plot is viewed in the direction of the Y axis (i.e. the X-Z plane is seen). Positive rotation values mean a counterclockwise rotation of the line of sight (or a clockwise rotation of the scene) around the vertical (Z) axis. Positive tilt values mean an ascension of the view point.\n\nExamples\n\n# Reset the view to the X-Y plane\n# (rotation=0, tilt=90)\nviewpoint(0, 90)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.rotate","page":"Plot attributes","title":"GRUtils.rotate","text":"rotate(angle::Int)\n\nRotate the viewpoint of the current plot by angle degrees around the vertical axis of the scene, with respect to its current position.\n\nExamples\n\n# Rotate 10 degrees to the right\nrotate(10)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.tilt","page":"Plot attributes","title":"GRUtils.tilt","text":"tilt(angle::Int)\n\nTilt (elevate) the viewpoint of the current plot by angle degrees over the horizontal plane, with respect to its current position.\n\nExamples\n\n# Tilt 10 degrees up\ntilt(10)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.movefocus","page":"Plot attributes","title":"GRUtils.movefocus","text":"movefocus(target)\n\nRotate the camera view axis, moving the focus to the target point.\n\nThis only affects 3-D scenes created with camera settings, e.g. isosurface plots. Moving the focus point rotates the camera without changing its position; in order to rotate the camera around the center of the scene, use the functions rotate, tilt or viewpoint.\n\nExamples\n\n# Move the focus to the point (1.0, 0.5, 0.0)\nmovefocus([1.0, 0.5, 0.0])\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.turncamera","page":"Plot attributes","title":"GRUtils.turncamera","text":"turncamera(angle)\n\nTurn the orientation of the camera by angle degrees around its view axis (only for 3-D scenes created with camera settings).\n\nExamples\n\n# Turn the perspective 10 degrees\nturncamera(10)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#Axis-scales","page":"Plot attributes","title":"Axis scales","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"xflip\nxlog\nradians","category":"page"},{"location":"api/attributes/#GRUtils.xflip","page":"Plot attributes","title":"GRUtils.xflip","text":"xflip(flag)\nyflip(flag)\nzflip(flag)\n\nReverse the direction of the X-, Y- or Z-axis (flag == true), or set them back to their normal direction (flag == false ).\n\nUse the keyword argument xflip=<true/false>, etc. in plotting functions, to set reversed axes during the creation of plots.\n\nExamples\n\n# Reverse the x-axis\nxflip(true)\n# Ensure that the y-axis is not reversed\nyflip(false)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.xlog","page":"Plot attributes","title":"GRUtils.xlog","text":"xlog(flag)\nylog(flag)\nzlog(flag)\n\nSet the X-, Y- or Z-axis to be drawn in logarithmic scale (flag == true), or in linear scale (flag == false).\n\nUse the keyword argument xlog=<true/false>, etc. in plotting functions, to set the logarithmic axes during the creation of plots.\n\nnote: Note\nWhen the axis is set to logarithmic scale, its lower limit is adjusted to represent only positive values, even if the data of the plot contain zero or negative values. The aspect of logarithmic axes with limits explicitly set to contain negative values (with xlim, etc.) is undefined.\n\nExamples\n\n# Set the x-axis limits to log scale\nxlog(true)\n# Ensure that the y-axis is in linear scale\nylog(false)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.radians","page":"Plot attributes","title":"GRUtils.radians","text":"radians(flag::Bool)\n\nSet the scale of angles in polar plots.\n\nUse radians(true) to represent angles in radians (default setting), and radians(false) to represent them in degrees.\n\nThis operation only modifies the guides of the polar plot grid lines. The existing geometries are left without changes\n\nUse the keyword argument radians=<true/false>, etc. in plotting functions, to set the scale of angles during the creation of polar plots.\n\nExample\n\n# Example data\nθ = LinRange(0, 2π, 40)\nr = sin.(θ)\n# Draw the polar plot (by default in radians)\npolar(θ, r)\n# Change the angula scale\nradians(false)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#Geometry-guides","page":"Plot attributes","title":"Geometry guides","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"legend\ngeometrykinds\ncolorbar","category":"page"},{"location":"api/attributes/#GRUtils.legend","page":"Plot attributes","title":"GRUtils.legend","text":"legend(labels...; kwargs...)\n\nSet the legend of the plot, using a series of labels (strings).\n\nIn addition to the legend strings, the keyword argument location can be used to define the location of the legend with respect to the plot axes and the keyword argument maxrows to distribute the legend labels in a grid with a maximum number of rows.\n\nLocations are defined as a number or a string, as indicated in the following table –- based on the convention of Matplotlib legends:\n\n⁣# String\n0 \"none\"\n1 \"upper right\"\n2 \"upper left\"\n3 \"lower left\"\n4 \"lower right\"\n5 \"right\"\n6 \"center left\"\n7 \"center right\"\n8 \"lower center\"\n9 \"upper center\"\n10 \"center\"\n11 \"outer upper right\"\n12 \"outer center right\"\n13 \"outer lower right\"\n\nThe labels are assigned to the geometries contained in the plot, in the same order as they were created. The assignment can be restricted to specific kinds of geometries through the keyword argument kinds, which can take a Symbol or a collection of Symbols that identify the kinds. Use the helper function geometrykinds to see the list of kinds available in the current plot.\n\nOnly geometries with non-empty labels and an available guide for legends will be presented in the legend.\n\nExamples\n\n# Set the legends to \"a\" and \"b\"\nlegend(\"a\", \"b\")\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.geometrykinds","page":"Plot attributes","title":"GRUtils.geometrykinds","text":"geometrykinds([p])\n\nReturn a list with symbols that represent the kind of the geometries included in the given plot or figure p.\n\nIf no argument is given, it takes the current plot of the current figure.\n\nExamples\n\njulia> # Plot a set of points at values `(x, y)`\njulia> # and a regression line passing through `(x, ŷ)`\njulia> scatter(x, y)\njulia> plot(x, ŷ)\njulia> geometrykinds()\n2-element Array{Symbol,1}:\n :scatter\n :line\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.colorbar","page":"Plot attributes","title":"GRUtils.colorbar","text":"colorbar(flag::Bool)\ncolorbar(levels::Integer)\n\nSet the color bar of the current plot.\n\nThe input argument can be a Bool (true or false) to show or hide the colorbar – if it is available, or an Integer to set the number of levels shown in the color bar (256 levels by default).\n\nColor bars are only presented when there is actual color data in the plot, regardless of the usage of this function.\n\nUse the keyword argument colorbar=<true/false>, etc. in plotting functions, to enable or disable the color bar during the creation of plots.\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#Colors","page":"Plot attributes","title":"Colors","text":"","category":"section"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"background\nbackground!\ncolormap","category":"page"},{"location":"api/attributes/#GRUtils.background","page":"Plot attributes","title":"GRUtils.background","text":"background(color[, alpha])\n\nAdd a custom background color to the current figure.\n\nThe argument can be an hexadecimal color code or nothing for a transparent background. A partially transparent color can be defined adding the alpha value between 0 and 1 as second argument.\n\nUse the keyword arguments backgroundcolor and backgroundalpha in plotting functions, to set a particular background color configuration during the creation of plots.\n\nThis overrides the default background defined by the colorscheme for the area outside the axes and legends of all the plots contained in the figure. Use background! to modify the background of individual subplots.\n\nExamples\n\n# Create a plot with light blue background\nplot(x, y, backgroundcolor=0x88ccff)\n# Remove the background\nbackground(nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.background!","page":"Plot attributes","title":"GRUtils.background!","text":"background!(p, bgcolor[, alpha])\n\nAdd a custom background color to the given plot object or to all the plots inside the given figure. See background for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.colormap","page":"Plot attributes","title":"GRUtils.colormap","text":"colormap(cmap)\ncolormap([cmap,] T::Type{<:Integer}[, byteorder::Bool=false])\n\nSet or retrieve the values of the current colormap.\n\nGive the identifier cmap to set the colormap. This identifier can be the number or a string with the name of any of the GR built-in colormaps.\n\nGive an integer data type T to return the set of colors defined in the current colormap, as a vector of hexadecimal color codes. By default those codes represent the word-ordered RGB values in a little-endian system. The optional argument byteorder can be set to true in order to retrieve the codes as byte-ordered codes.\n\nAt least one of the arguments cmap::Union{Integer, AbstractString} or T::Type{<:Integer} are required. If cmap not given, the previous colormap is left as current. If T is not given, the function returns nothing.\n\nExamples\n\n# Create example point data\nx = 8 .* rand(100) .- 4\ny = 8 .* rand(100) .- 4\nz = sin.(x) + cos.(y)\n# Use the \"hot\" colormap\ncolormap(\"hot\")\ncontourf(x, y, z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/colormap.jl\") # hide","category":"page"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"colormap!\ncolorscheme","category":"page"},{"location":"api/attributes/#GRUtils.colormap!","page":"Plot attributes","title":"GRUtils.colormap!","text":"colormap!(p, cmap)\n\nApply a colormap cmap to the given plot p, which can be a PlotObject, or a Figure (in such case the colormap is applied to all the plots contained in it).\n\nThe value of cmap can be the number or the name of any of the GR built-in colormaps (see colormap for more details).\n\nUse the keyword argument colormap in plotting functions, to set a particular colormap during the creation of plots (in this case it can only be identified by its number).\n\nExamples\n\n# Create a surface plot with the \"grayscale\" colormap (2)\nsurface(x, y, z, colormap=2)\n# Change it to the \"viridis\" colormap\ncolormap!(gcf(), \"viridis\")\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/#GRUtils.colorscheme","page":"Plot attributes","title":"GRUtils.colorscheme","text":"colorscheme(scheme)\n\nSet the color scheme for subsequent plots.\n\nThe value of the scheme can be one of the following numbers or strings:\n\n0: \"none\"\n1: \"light\"\n2: \"dark\"\n3: \"solarized light\"\n4: \"solarized dark\"\n\nThe scheme applies to all plots that are drawn after calling colorscheme, even if they have been created beforehand. To apply a particular scheme to some plot or figure, use colorscheme!.\n\nIf the scheme is \"none\" (0), the standard scheme is set, which is the same as \"light\" (1), except that the default background of the figure is transparent.\n\nExamples\n\n# Create example data\nx = LinRange(0, 3, 20)\ny = [sin.(x) exp.(-x)]\n# Set a new color scheme and plot the data\nsubplot(1,2,1)\ncolorscheme(\"light\")\nplot(x, y)\n# Make a second plot with a particular scheme\nsubplot(1,2,2)\nplot(x, y, scheme=3) # solarized light\n# Now change the global scheme and redraw\n# (this only affects the first plot)\ncolorscheme(\"solarized dark\")\ndraw(gcf())\n\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"Figure((600,250)); # hide\nBase.include(GRUtils, \"../examples/docstrings/colorscheme.jl\") # hide","category":"page"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"colorscheme!","category":"page"},{"location":"api/attributes/#GRUtils.colorscheme!","page":"Plot attributes","title":"GRUtils.colorscheme!","text":"colorscheme!(p, scheme)\n\nApply a color scheme to the given plot p, which can be a PlotObject, or a Figure (in such case the scheme is applied to all the plots contained in it).\n\nThe value of scheme can be the number or the name of any available color scheme (see colorscheme for more details).\n\nUse the keyword argument scheme in plotting functions, to set a particular color scheme during the creation of plots (in this case only the number of an already exisiting scheme is allowed).\n\nExamples\n\n# Create a plot with a dark scheme (2)\nplot(x, y, scheme=2)\n# Change it to the standard light scheme\ncolorscheme!(currentplot(), \"light\")\n\n\n\n\n\n","category":"function"},{"location":"api/attributes/","page":"Plot attributes","title":"Plot attributes","text":"colormap(\"viridis\") # hide\ncolorscheme(\"none\") # hide","category":"page"},{"location":"internals/drawing/#Drawing-plots","page":"Drawing plots","title":"Drawing plots","text":"","category":"section"},{"location":"internals/drawing/","page":"Drawing plots","title":"Drawing plots","text":"The function draw executes the instructions that create the graphical visualization of a plot and its components. That function has specialized methods for the different types that have been described in the Structure of plots. In a top-down order:","category":"page"},{"location":"internals/drawing/","page":"Drawing plots","title":"Drawing plots","text":"draw(::Figure) sets up the workspace and calls the draw method for all the PlotObjects  contained in plots.\ndraw(::PlotObject) does the following actions:\nPaint the background and set the viewport defined by the viewport field.\nCall the method draw on the plot's axes.\nCall the method draw on each item of geoms.\nCall draw on legend it is not an empty legend and attributes[:location] ≠ 0.\nCall draw on colorbarif it is not an empty color bar and attributes[:colorbar] == true).\nWrite different labels and decorations in axes, title, etc, as defined in attributes.\ndraw(::Axes) sets the window and the scale defined by the axes ranges and other specifications &mdash; except in the case of polar plots, where the polar coordinates are transformed into the Cartesian coordinates of a square of fixed size, and then draws the axes themselves and their guides.\ndraw(::Geometry) calls specialized methods for the geometry's kind, and returns either nothing or a Vector{Float64} with the limits of the color scale &mdash; when it is calculated by the drawing operation, e.g. in the case of hexagonal bins.\nLegends are drawn by the method draw(lg::Legend, geoms, location), where geoms is a vector with the geometries of the plot, and location is an integer code that defines the location of the legend with respect to the main plot area — as defined in Matplotlib legends. The geometries are passed down to the guide function, which has specialized methods for the kind of geometries that can be represented in legends.\nColor bars are drawn by the method draw(cb::Colorbar [, range]), where the optional range is by default cb.range, but can be overriden by other values.","category":"page"},{"location":"internals/drawing/","page":"Drawing plots","title":"Drawing plots","text":"The draw method can be used on a Figure to trigger its graphical representation, but in most situations it is not necessary to call it explicitly. It is called automatically whenever a figure is meant to be shown in an environment that support SVG, PNG or HTML outputs, such as IJulia notebooks, web-content generators like Weave or Documenter, etc. And there is also a display method that dispatches on Figure, whose main action is calling the corresponding draw method, to display figures in rich multimedia devices.","category":"page"},{"location":"internals/drawing/","page":"Drawing plots","title":"Drawing plots","text":"Thus, one way or another, figures are usually drawn automatically by just invoking them, e.g. if in the last line of a code block you write gcf(), the name of a variable containing a figure, or if you call a function like plot that returns a Figure.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"CurrentModule = GRUtils","category":"page"},{"location":"internals/structure/#Structure-of-plots","page":"Structure of plots","title":"Structure of plots","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"GRUtils replaces some long, convoluted functions of jlgr with many if-else blocks by more numerous, but smaller functions based on type-dispatch, and takes advantage of meta-programming, such that those functions can be revised and debugged easily, and new utilities can be added with new functions and methods, without having to modify the existing ones.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Plots are composed of a set of objects of different types, which are defined below, along with some notes comparing this structure with the plots produced in jlgr.","category":"page"},{"location":"internals/structure/#Figures","page":"Structure of plots","title":"Figures","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Figures are the \"top-level\" objects, that contain all the information of a plot or set of \"subplots\" that are meant to be drawn together. This is represented by the type Figure, which is basically a collection of plots, gathered in a graphic workstation of a given size. Its structure is simple, defined in a very basic constructor:","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Figure","category":"page"},{"location":"internals/structure/#GRUtils.Figure","page":"Structure of plots","title":"GRUtils.Figure","text":"Figure(workstation::Tuple{Float64, Float64}, plots::Vector{PlotObject})\n\nReturn a new figure, defined by:\n\nworkstation: a Tuple{Float64, Float64} with the width and height of the   overall plot container (workstation), in pixels.\nplots: a vector of PlotObject elements, which contain the information of   the individual plots included in the figure.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/#Plot-objects","page":"Structure of plots","title":"Plot objects","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"The type PlotObject provides the data structure for what can be considered a \"complete\" single plot. This type is roughly equivalent to the type of the same name defined in jlgr, although its structure is quite different:","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"PlotObject","category":"page"},{"location":"internals/structure/#GRUtils.PlotObject","page":"Structure of plots","title":"GRUtils.PlotObject","text":"PlotObject(viewport, axes, geoms, legend, colorbar, attributes)\nPlotObject(viewport, axes, geoms, legend, colorbar; kwargs...)\n\nReturn a PlotObject containing the following parameters:\n\nviewport: a Viewport object, which defines the area covered by the   plot and the coordinate axes in the display.\naxes: an Axes object that defines how to represent the   coordinate axes of the space where the plot is contained.\ngeoms: a Vector of Geometry objects that are plotted in the axes.\nlegend: a Legend object that defines how to present a legend of the   different geometries (if required).\ncolorbar: a Colorbar object that defines how to present the guide   to the color scale (if required).\nattributes: a dictionary (Dict{Symbol, Any}) with varied plot attributes,   including the title, axis labels, and other data that modify the default way   of representing the different components of the plot. Those attributes   can be passed to the PlotObject constructor as keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"All the parameters of a PlotObject are instances of other types for the different elements of a plot, which are defined below. PlotObject is a mutable type, which means that those parameters can be replaced by others of the same type without having to replace the whole object.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"The last plot of a figure f is considered itself its \"current plot\", and can be referred to by the function currentplot(f). If no argument is given to currentplot(), the last plot of the current figure is returned — equivalent to currentplot(gcf()).","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"note: Note\nIn jlgr, the function gcf() directly returns the global current plot, which can also be identified by jlgr.plt.","category":"page"},{"location":"internals/structure/#Viewport","page":"Structure of plots","title":"Viewport","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Viewport","category":"page"},{"location":"internals/structure/#GRUtils.Viewport","page":"Structure of plots","title":"GRUtils.Viewport","text":"Viewport(outer::Vector{Float64}, inner::Vector{Float64})\n\nReturn a Viewport object, defining the \"normalized device coordinates\" (NDC) of the outer box that contains all the elements of the plot, and the inner box where the main items (axes and geometries) are plotted.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"The Viewport of a plot defines the \"normalized device coordinates\" (NDC) of the outer box that contains all the elements of a plot, and of the inner box where the main items (axes and geometries) are plotted.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Such boxes are defined by 4 coordinates; the first and second coordinates are the distances between the left margin of the device and the left and right borders of the box, respectively; the third and fourth coordinates are the distances between the bottom of the device and the bottom and top borders, respectively.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"(Image: Box coordinates)","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"NDC are given in dimensionless units between 0 and 1, such that (0, 1, 0, 1) means a box that spans over the whole device.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"note: Note\nIn jlgr, the outer and inner boxes of a plot are described in the field kvs of the corresponding PlotObject item. For instance, for the global \"current plot\" plt, the coordinates of the outer box are plt.kvs[:viewport], and for the inner box they are plt.kvs[:vp].)","category":"page"},{"location":"internals/structure/#Geometries","page":"Structure of plots","title":"Geometries","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Geometry","category":"page"},{"location":"internals/structure/#GRUtils.Geometry","page":"Structure of plots","title":"GRUtils.Geometry","text":"Geometry(kind, x, y, z, c, spec, label, attributes)\n\nReturn a Geometry containing the data represented in a plot by means of geometric elements (lines, markers, shapes, etc.).\n\nEach Geometry has a kind, given by a Symbol with the name of the geometric element that it represents, such as :line for lines, :scatter for scattered points, :bar for bars, etc. In addition it has the following fields:\n\nx, y, z, c: Vectors of Float64 numbers that are mapped to different   characteristics of the geometry. x and y are normally their X and Y   coordinates; z usually is its Z coordinate in 3-D plots, or another   aesthetic feature (e.g. the size in scatter plots); c is usually meant   to represent the color scale, if it exists.\nspec: a String with the specification of the line style, the type of marker   and the color of lines in line plots.   (Cf. the defintion of format strings in matplotlib)\nlabel: a String with the label used to identify the geometry in the plot legend.\nattributes: a Dict{Symbol, Float64} with extra attributes to control how   geometries are plotted.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"note: Note\nIn jlgr, all those data except the ones contained in the field attributes are given in the elements of the args vector of the corresponding PlotObject item.","category":"page"},{"location":"internals/structure/#Axes","page":"Structure of plots","title":"Axes","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Axes","category":"page"},{"location":"internals/structure/#GRUtils.Axes","page":"Structure of plots","title":"GRUtils.Axes","text":"Axes(kind, ranges, tickdata, ticklabels, perspective, camera, options)\n\nReturn an Axes object, containing the graphical specifications of the coordinate system of a plot.\n\nAxes are determined by their kind, which may be :axes2d for 2-D plots, :axes3d for 3-D plots, and :polar for polar plots. The rest of its fields are:\n\nranges: boundaries of the different axes/scales. They are given as a dictionary   whose keys are symbols with the name of the axis (:x, :y, :z, :c),   and whose values are tuples with two float values — the minimum and maximum   values, respectively. The range (Inf, -Inf) describes an undefined axis.\ntickdata: numeric specifications of the \"ticks\" that are drawn on the axes.   They are given as a dictionary whose keys are the names of the axis (as for range),   and whose values are tuples that contain for that axis: (1) a Float64 with   the \"minor\" value between consecutive ticks; (2) a 2-tuple of Float64 with   the ends of the axis ticks; and (3) an Int with the number of minor ticks   between \"major\", numbered ticks.\nticklabels: transformations between tick values and labels. They are given   as a dictionary whose keys are the names of the axis, and whose values are   functions that accept a number as argument, and return a string with the   text that must be written at major ticks. (This only works for the X and Y axes).\nperspective: A Vector{Int} that contains the \"rotation\" and \"tilt\" angles   that are used to project 3-D axes on the plot plane. (Only for 3-D plots)\ncamera: A Vector{Float64} with the camera parameters (camera position,   view center and \"up\" vector, only used for 3-D plots).\noptions: A Dict{Symbol, Int} with extra options that control the visualization   of the axes. Currently supported options are:\noptions[:scale], an integer code that defines what axes are must be   plotted in log scale or reversed (cf. the function GR.setscale).\noptions[:grid] = 0 to hide the plot grid, or any other value to show it.\noptions[:tickdir] to determine how the ticks are drawn   (positive value to draw them inside the plot area, negative value to   draw them outside, or 0 to hide them).\noptions[:gr3] ≠ 0 to identify if the axes are a 3-D scene defined for the gr3 interface.\noptions[:radians] = 0 to transform angular values to degrees in polar axes.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"note: Note\nIn jlgr, most of those data are described in the dictionary kvs contained in the corresponding PlotObject item, or calculated during plotting operations without being stored.","category":"page"},{"location":"internals/structure/#Legends","page":"Structure of plots","title":"Legends","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Legend","category":"page"},{"location":"internals/structure/#GRUtils.Legend","page":"Structure of plots","title":"GRUtils.Legend","text":"Legend(size::Tuple{Float64, Float64}, cursors::Vector{Tuple{Float64, Float64}})\n\nReturn a Legend object.\n\nThis type defines the frame where a legend is plotted. The fields contained in a Legend object are a 2-tuple with the size of the legend box in NDC (width and height, respectively), and a vector of 2-tuples with the positions of the legend items.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"The symbols and labels that should be shown in the legend are not described in the Legend object, but they are fetched from the Geometry objects used in the plot where the legend is defined.","category":"page"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"note: Note\nIn jlgr, those values are not stored in any parameter of plot objects. Only the relative position of the legend with respect to the axes area is stored, and everything is calculated in the moment of drawing the plot.)","category":"page"},{"location":"internals/structure/#Color-bars","page":"Structure of plots","title":"Color bars","text":"","category":"section"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"Colorbar","category":"page"},{"location":"internals/structure/#GRUtils.Colorbar","page":"Structure of plots","title":"GRUtils.Colorbar","text":"Colorbar(range, tick, scale, margin, colors)\n\nReturn a Colorbar object containing the data that defines the colorbar associated to a plot.\n\nThe fields contained in a Legend object are:\n\nrange: a Tuple{Float64, Float64} with the range of the color scale   represented in the bar.\ntick: a Float64 that gives the distance between tick marks drawn as   guide next to the bar.\nscale: an Int code used by GR.setscale to define the   scale of the bar (basically, if it is presented as linear or log scale).\nmargin: a Float64 with the size of the extra margin between the main   plot frame and the bar.\ncolors: an Int indicating the number of different grades in the color scale.\n\n\n\n\n\n","category":"type"},{"location":"internals/structure/","page":"Structure of plots","title":"Structure of plots","text":"note: Note\nIn jlgr, those values are not stored in any parameter of plot objects, and everything is calculated in the moment of drawing the plot, if suitable.","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"using GRUtils, Random\nRandom.seed!(111)","category":"page"},{"location":"api/plotting/#Plotting-functions","page":"Plotting functions","title":"Plotting functions","text":"","category":"section"},{"location":"api/plotting/#Line-plots","page":"Plotting functions","title":"Line plots","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"plot","category":"page"},{"location":"api/plotting/#GRUtils.plot","page":"Plotting functions","title":"GRUtils.plot","text":"plot(x[, y, spec; kwargs...])\nplot(x1, y1, x2, y2...; kwargs...)\nplot(x1, y1, spec1...; kwargs...)\n\nDraw one or more line plots.\n\nLines are defined by the x and y coordinates of the connected points, given as numeric vectors, and optionally the format string spec that defines the line and marker style and color as in matplotlib.\n\nThe y vector can be replaced by a callable that defines the Y coordinates as a function of the X coordinates.\n\nMultiple lines can be defined by pairs of x and y coordinates (and optionally their format strings), passed sequentially as arguments of plot. Alternatively, if various lines have the same X coordinates, their Y values can be grouped as columns in a matrix.\n\nIf no spec is given, the series will be plotted as solid lines with a predefined sequence of colors.\n\nAdditionally, specifications of lines and markers can be defined by keyword arguments:\n\nlinewidth: line width scale factor.\nmarkersize: marker size scale factor.\nlinecolor: hexadecimal RGB color code for the line.\nmarkercolor: hexadecimal RGB color code for the markers.\n\nThis function can receive a single numeric vector or matrix, which will be interpreted as the Y coordinates; in such case the X coordinates will be a sequence of integers starting at 1.\n\nExamples\n\n# Create example data\nx = LinRange(-2, 2, 40)\nf(t) = t^3 + t^2 + t\ny = f.(x)\n# Plot x and y\nplot(x, y)\n# Plot x using the callable\nplot(x, f)\n# Plot y, using its indices for the x values\nplot(y)\n# Plot two columns\nplot(x, [y 3x.^2 .- 3])\n# Plot various series them with custom line specs\ny2 = 3x.^2 .- 3\nplot(x, y, \"-r\", x, y2, \":*b\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/plot.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"oplot","category":"page"},{"location":"api/plotting/#GRUtils.oplot","page":"Plotting functions","title":"GRUtils.oplot","text":"oplot(args...; kwargs...)\n\nDraw one or more line plots over another plot.\n\nEquivalent to calling plot after holding the current plot, except that the axes limits are not re-adjusted to the new data.\n\nExamples\n\n# Create example data\nx = LinRange(-2, 2, 40)\ny = 2 .* x .+ 4\n# Draw the first plot\nplot(x, y)\n# Plot another graph over it\noplot(x, x -> x^3 + x^2 + x)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/oplot.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"stair","category":"page"},{"location":"api/plotting/#GRUtils.stair","page":"Plotting functions","title":"GRUtils.stair","text":"stair(x[, y, spec; kwargs...])\nstair(x1, y1, x2, y2...; kwargs...)\nstair(x1, y1, spec1...; kwargs...)\n\nDraw one or more staircase or step plots.\n\nThe coordinates and format of the stair outlines are defined as for line plots (cf. plot).\n\nAdditionally, the keyword argument where can be used to define where the \"stairs\" (vertical discontinuities between Y values) shoud be placed:\n\nwhere = \"pre\" to make the steps stop at each point (x[i], y[i]),   starting at the previous x coordinate except for the first point.\nwhere = \"post\" to make the steps start at each point (x[i], y[i]),   stopping at the next x coordinate except for the last point.\nwhere = \"mid\" (default) to make the steps go through each point (x[i], y[i])   starting and ending in the middle of the surrounding x-intervals,   except for the first and last points.\n\nExamples\n\n# Create example data\nx = LinRange(-2, 2, 40)\ny = x.^3 .+ x.^2 .+ x\n# Plot x and y\nstair(x, y)\n# Plot y with indices for x values\nstair(y)\n# step directly after x each position\nstair(y, where=\"pre\")\n# step between two x positions\nstair(y, where=\"mid\")\n# step immediately before x each position\nstair(y, where=\"post\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/stair.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"plot3","category":"page"},{"location":"api/plotting/#GRUtils.plot3","page":"Plotting functions","title":"GRUtils.plot3","text":"plot3(x, y, z[, spec; kwargs...])\nplot3(x1, y1, z1, x2, y2, z2...; kwargs...)\nplot3(x1, y1, z1, spec1...; kwargs...)\n\nDraw one or more three-dimensional line plots.\n\nLines are defined by the x, y and z coordinates of the connected points, given as numeric vectors, and optionally the format string spec that defines the line and marker style and color as in matplotlib.\n\nThe z vector can be replaced by a callable that defines the Z coordinates as a function of the X and Y coordinates.\n\nMultiple lines can be defined by triplets of x, y and z coordinates (and optionally their format strings), passed sequentially as arguments of plot3.\n\nIf no specs are given, the series will be plotted as solid lines with a predefined sequence of colors.\n\nAdditionally, specifications of lines and markers can be defined by keyword arguments:\n\nlinewidth: line width scale factor.\nmarkersize: marker size scale factor.\nlinecolor: hexadecimal RGB color code for the line.\nmarkercolor: hexadecimal RGB color code for the markers.\n\nExamples\n\n# Create example data\nx = LinRange(0, 30, 1000)\ny = cos.(x) .* x\nz = sin.(x) .* x\n# Draw a solid line and another with star markers\n# in one of every 10 points\nplot3(x, y, z, x[1:10:end], y[1:10:end], z[1:10:end], \"p\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/plot3.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"polar","category":"page"},{"location":"api/plotting/#GRUtils.polar","page":"Plotting functions","title":"GRUtils.polar","text":"polar(angle, radius[, spec; kwargs...])\n\nDraw one or more polar plots.\n\nThe first coordinate the represents the angle, and the second the radius of the line points. The rest is defined as for line plots, except that the first variable (angle) is always required. (cf. plot).\n\nThe first variable is by default considered to be radians, and the angular labels of the grid are shown as factors of π. Use the keyword argument radians = false to pass and show angles in degrees.\n\nnote: Note\nLogarithmic and reversed scales ar disabled in polar plots\n\nExamples\n\n# Create example data\nangles = LinRange(0, 360, 40)\nradii = LinRange(0, 2, 40)\n# Draw the polar plot in degrees\npolar(angles, radii, radians=false)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/polar.jl\") # hide","category":"page"},{"location":"api/plotting/#Scatter-plots","page":"Plotting functions","title":"Scatter plots","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"scatter","category":"page"},{"location":"api/plotting/#GRUtils.scatter","page":"Plotting functions","title":"GRUtils.scatter","text":"scatter(x[, y, size, color; kwargs...])\n\nDraw a scatter plot.\n\nPoints are defined by their x and y coordinates, given as numeric vectors. Additionally, values for markers' size and color can be provided. Size values will determine the marker size in percent of the regular size, and color values will be used in combination with the current colormap.\n\nThe last variable can be replaced by a callable that defines it as a function of the previous variables.\n\nThis function can receive a single numeric vector or matrix, which will be interpreted as the Y coordinates; in such case the X coordinates will be a sequence of integers starting at 1.\n\nExamples\n\n# Create example data\nx = LinRange(0, 1, 11)\ny = LinRange(0, 1, 11)\ns = LinRange(50, 400, 11)\nc = LinRange(0, 255, 11)\n# Plot the points with increasing size and color\nscatter(x, y, s, c)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/scatter.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"scatter3","category":"page"},{"location":"api/plotting/#GRUtils.scatter3","page":"Plotting functions","title":"GRUtils.scatter3","text":"scatter3(x, y, z[, color; kwargs...])\n\nDraw a three-dimensional scatter plot.\n\nPoints are defined by their x, y and z coordinates, given as numeric vectors. Additionally, values for markers' color can be provided, which will be used in combination with the current colormap.\n\nThe last variable can be replaced by a callable that defines it as a function of the previous variables.\n\nExamples\n\n# Create example data\nx = 2 .* rand(100) .- 1\ny = 2 .* rand(100) .- 1\nz = 2 .* rand(100) .- 1\nc = 999 .* rand(100) .+ 1\n# Plot the points with colors\nscatter3(x, y, z, c)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/scatter3.jl\") # hide","category":"page"},{"location":"api/plotting/#Stem-plots","page":"Plotting functions","title":"Stem plots","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"stem","category":"page"},{"location":"api/plotting/#GRUtils.stem","page":"Plotting functions","title":"GRUtils.stem","text":"stem(x[, y, spec; kwargs...])\nstem(x1, y1, x2, y2...; kwargs...)\nstem(x1, y1, spec1...; kwargs...)\n\nDraw a stem plot\n\nThe coordinates and format of the stems and markers are defined as for line plots (cf. plot).\n\nAdditionally, the keyword argument baseline can be used to define the Y coordinate where stems should start from.\n\nExamples\n\n# Create example data\nx = LinRange(-2, 2, 40)\ny = x.^3 .+ x.^2 .+ x .+ 6\n# Plot x and y, with dashed stems ended in a star\nstem(x, y, \"--p\")\n# Move the baseline to 5\nstem(x, y, baseline = 5)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/stem.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"errorbar","category":"page"},{"location":"api/plotting/#GRUtils.errorbar","page":"Plotting functions","title":"GRUtils.errorbar","text":"errorbar(x, y, err[, spec; kwargs...])\nerrorbar(x, y, errlow, errhigh[, spec; kwargs...])\n\nDraw a series of error bars.\n\nError bars are defined by their x and y coordinates, and the size of the error bars at either of each (x, y) point. For symmetric error bars, only a vector err is required, such that their total size will be 2 .* err. For asymmetric error bars, two vectors errlow and errhigh are required, such that the size of the error bars will be errlow .+ errhigh.\n\nThe optional format string spec defines the style and color of the lines of error bars and the markers at (x, y), as in matplotlib. If no specs are given, the error bars will be plotted as solid lines with a predefined sequence of colors, without markers.\n\nAdditionally, the following keyword arguments can be used to modify the aspect of the error bars:\n\nlinewidth::Float64: line width scale factor.\nmarkersize::Float64: marker size scale factor.\nlinecolor: hexadecimal RGB color code for the line.\nhorizontal::Bool: set it to true to draw horizontal error bars).\ncapwidth: fixed value of the width of the bar \"caps\", in units of   the X axis (or Y axis if horizontal is true). If it is not given,   the cap width will be automatically adjusted to 0.3 times the mean   separation between data points.\n\nExamples\n\n# Create example data\nx = LinRange(-2, 2, 10)\ny = x.^3 .+ x.^2 .+ x .+ 6\nerr = LinRange(0.5, 3, 10)\n# Draw symmetric, horizontal error bars\nerrorbar(x, y, err, horizontal=true)\n# Draw asymmetric error bars with markers\nerrorbar(x, y, err, err./2, \"-o\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/errorbar.jl\") # hide","category":"page"},{"location":"api/plotting/#Bar-plots","page":"Plotting functions","title":"Bar plots","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"barplot","category":"page"},{"location":"api/plotting/#GRUtils.barplot","page":"Plotting functions","title":"GRUtils.barplot","text":"bar(labels, heights; kwargs...)\nbar(heights; kwargs...)\n\nDraw a bar plot.\n\nIf no specific labels are given, the bars are labelled with integer numbers starting from 1.\n\nIf heights is a matrix, each column is taken as a different set of data, which are represented as bars of different colors. Use the keyword argument barposition with the values \"grouped\" (default) or \"stacked\" to control if the bars are positioned side by side or stacked on top of the previous series.\n\nThe keyword arguments barwidth, baseline and horizontal can also be used to modify the aspect of the bars, which by default is:\n\nbarwidth = 0.8 (80% of the separation between bars).\nbaseline = 0.0 (bars starting at zero).\nhorizontal = false (vertical bars)\n\nThe color of the bars is selected automatically, unless a specific hexadecimal RGB color code is given through the keyword argument color.\n\nExamples\n\n# Create example data (continent population in million people)\ncontinents = [\"Africa\", \"America\", \"Asia\", \"Europe\", \"Oceania\"]\npopulation_1960 = [285, 425, 1687, 606, 16]\npopulation_2010 = [1044, 944, 4170, 735, 36]\npopulation_matrix = [population_1960 population_2010]\n# Plot with respect to 500 millions of people\nbarplot(continents, population_matrix, baseline=500)\nlegend(\"1960\", \"2010\") # add legend\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/barplot.jl\") # hide","category":"page"},{"location":"api/plotting/#Vector-fields","page":"Plotting functions","title":"Vector fields","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"quiver","category":"page"},{"location":"api/plotting/#GRUtils.quiver","page":"Plotting functions","title":"GRUtils.quiver","text":"quiver(x, y, u, v[, spec; kwargs...])\n\nDraw a vector field at points (x,y) with arrows of size (u,v).\n\nThe style and color of the arrow lines and – optionally – the markers drawn at the (x,y) points can be configured through the format string spec and keyword arguments, as in plot and other functions.\n\nUse the keyword arguments arrowscale and headsize to give a scale factor for the size of the arrows and their heads.\n\nExamples\n\n# Create example data\nx = repeat(LinRange(-2, 2, 20), inner=10)\ny = repeat(LinRange(-1, 1, 10), outer=20)\nu = x .* (x.^2 .+ y.^2)\nv = y .* (x.^2 .+ y.^2)\n# Plot arrows\nquiver(x, y, u, y, arrowscale=0.1)\n# Expand the y-axes to see the whole arrows\nylim(-1.15, 1.15)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/quiver.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"quiver3","category":"page"},{"location":"api/plotting/#GRUtils.quiver3","page":"Plotting functions","title":"GRUtils.quiver3","text":"quiver3(x, y, z, u, v, w[, spec; kwargs...])\n\nDraw a three-dimensional vector field at points (x,y,z) with arrows of size (u,v,w).\n\nThe style and color of the arrow lines and – optionally – the markers drawn at the (x,y,z) points can be configured through the format string spec and keyword arguments, as in plot and other functions.\n\nUse the keyword argument arrowscale to give a scale factor for the size of the arrows.\n\nnote: Note\nUnlike in the case of 2d quiver plots, the 3-D arrows of quiver3 do not have heads.\n\nExamples\n\n# Create example data\nx = repeat(LinRange(-2, 2, 20), inner=10)\ny = repeat(LinRange(0, pi, 10), outer=20)\nz = sin.(x) .+ cos.(y)\nu = 0.1ones(200)\nv = zeros(200)\nw = 0.5z\n# Plot vectors\nquiver3(x, y, z, u, v, w, \"o\", markersize=0.5)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/quiver3.jl\") # hide","category":"page"},{"location":"api/plotting/#Histograms","page":"Plotting functions","title":"Histograms","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"histogram","category":"page"},{"location":"api/plotting/#GRUtils.histogram","page":"Plotting functions","title":"GRUtils.histogram","text":"histogram(data; kwargs...)\n\nDraw a histogram of data.\n\nThe following keyword arguments can be supplied:\n\nnbins: Number of bins; by default, or if a number smaller than 1 is given,   the number of bins is computed as 3.3 * log10(n) + 1,  with n being the   number of elements in data.\nhorizontal: whether the histogram should be horizontal (false by default).\ncolor: hexadecimal RGB color code for the bars.\n\nnote: Note\nIf the vertical axis (or the horizontal axis if horizontal == true) is set in logarithmic scale, the bars of the histogram will start at 1.0.\n\nExamples\n\n# Create example data\ndata = 2 .* randn(100) .- 1\n# Draw the histogram with 19 bins\nhistogram(data, nbins=19)\n# Horizontal histogram with log scale\nhistogram(data, horizontal=true, xlog=true)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/histogram.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"polarhistogram","category":"page"},{"location":"api/plotting/#GRUtils.polarhistogram","page":"Plotting functions","title":"GRUtils.polarhistogram","text":"polarhistogram(data; kwargs...)\n\nDraw a polar histogram of angle values contained in data.\n\nThe following keyword arguments can be supplied:\n\nnbins: Number of bins; by default, or if a number smaller than 1 is given,   the number of bins is computed as 3.3 * log10(n) + 1,  with n being the   number of elements in data.\nradians: Set this argument to false to pass and show the angles as degrees.   By default, data is assumed to be radians and the angular labels of the   grid are presented as factors of π.\nfullcircle: Set this argument to true to scale the angular coordinates of   the histogram and make the bars span over the whole circle.\ncolor: hexadecimal RGB color code for the bars.\n\nnote: Note\nLogarithmic and reversed scales ar disabled in polar plots\n\nExamples\n\n# Create example data\ndata = randn(100)\n# Draw a polar histogram with 19 bins\npolarhistogram(data, nbins = 19, fullcircle=true)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/polarhistogram.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"hexbin","category":"page"},{"location":"api/plotting/#GRUtils.hexbin","page":"Plotting functions","title":"GRUtils.hexbin","text":"hexbin(x, y; kwargs...)\n\nDraw a hexagon binning plot.\n\nHexagonal binning and the the current colormap are used to display a bi-dimensional series of points given by x and y. The number of bins is 40 by default; use the keyword argument nbins to set it as a different number.\n\nExamples\n\n# Create example data\nx = randn(100_000)\ny = randn(100_000)\n# Draw the hexbin plot\nhexbin(x, y)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/hexbin.jl\") # hide","category":"page"},{"location":"api/plotting/#Contour-plots","page":"Plotting functions","title":"Contour plots","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"contour","category":"page"},{"location":"api/plotting/#GRUtils.contour","page":"Plotting functions","title":"GRUtils.contour","text":"contour([x, y,] z; kwargs...)\n\nDraw a contour plot.\n\nThe current colormap is used to display a either a series of points or a two-dimensional array as a contour plot. It can receive one of the following:\n\nx values, y values and z values.\nM sorted values of the x axis, N sorted values of the y axis,   and a set of z values on a N×M grid.\nM sorted values of the x axis, N sorted values of the y axis,   and a callable to determine z values.\nz values on a N×M grid, with the x and y axes   defined as the indices of the columns and rows of the grid, respectively.\n\nIf a series of points is passed to this function, their values will be interpolated on a grid. For grid points outside the convex hull of the provided points, a value of 0 will be used.\n\nContour lines are colored by default, using the current colormap as color scale. Colored lines can be disabled by removing the color bar (with keyword argument colorbar == false).\n\nThe following keyword arguments can be provided to set the number and aspect of the contour lines:\n\nlevels::Int, the number of contour lines that will be fitted to the data   (20 by default).\nmajorlevels::Int, the number of levels between labelled contour lines   (no labels by default for colored lines, all lines labelled by default   if color is removed).\n\nExamples\n\n# 1. Create example point data\nx = 8 .* rand(100) .- 4\ny = 8 .* rand(100) .- 4\nz = sin.(x) + cos.(y)\n# Contour plot on the left without color (lines labelled by default)\nsubplot(1, 2, 1)\ncontour(x, y, z, colorbar = false)\n# 2. Create example grid data with a callable\nx = LinRange(-2, 2, 40)\ny = LinRange(0, pi, 20)\nf(x, y) = sin(x) + cos(y)\n# Contour plot on the right with color\n# and explicit labels every three lines\nsubplot(1, 2, 2)\ncontour(x, y, f, majorlevels = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/contour.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"contourf","category":"page"},{"location":"api/plotting/#GRUtils.contourf","page":"Plotting functions","title":"GRUtils.contourf","text":"contourf([x, y,] z; kwargs...)\n\nDraw a filled contour plot.\n\nThe current colormap is used to display a either a series of points or a two-dimensional array as a filled contour plot. It can receive one of the following:\n\nx values, y values and z values.\nM sorted values of the x axis, N sorted values of the y axis,   and a set of z values on a N×M grid.\nM sorted values of the x axis, N sorted values of the y axis,   and a callable to determine z values.\nz values on a N×M grid, with the x and y axes   defined as the indices of the columns and rows of the grid, respectively.\n\nIf a series of points is passed to this function, their values will be interpolated on a grid. For grid points outside the convex hull of the provided points, a value of 0 will be used.\n\nThe following keyword arguments can be provided to set the number and aspect of the contour lines:\n\nlevels::Int, the number of contour lines that will be fitted to the data   (20 by default).\nmajorlevels::Int, the number of levels between labelled contour lines   (no labels by default).\n\nExamples\n\n# 1. Create example point data\nx = 8 .* rand(100) .- 4\ny = 8 .* rand(100) .- 4\nz = sin.(x) + cos.(y)\n# Contour plot\ncontourf(x, y, z)\n# 2. Create example grid data with a callable\nx = LinRange(-2, 2, 40)\ny = LinRange(0, pi, 20)\nf(x, y) = sin(x) + cos(y)\n# Contour plot with 25 lines, labelling a quarter of them\ncontourf(x, y, f, levels = 25, majorlevels = 4)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/contourf.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"tricont","category":"page"},{"location":"api/plotting/#GRUtils.tricont","page":"Plotting functions","title":"GRUtils.tricont","text":"tricont(x, y, z; kwargs...)\n\nDraw a triangular contour plot.\n\nThe current colormap is used to display a series of points as a triangular contour plot. z values are interpolated between x and y values through Delaunay triangulation.\n\nThe number of contour lines can be set by the keyword argument levels (by default levels = 20).\n\nnote: Note\nIf the series of points is concave, there may be interpolation artifacts on the edges of the plot, as the interpolation may occur in very acute triangles.\n\nExamples\n\n# Create example point data\nx = 8 .* rand(100) .- 4\ny = 8 .* rand(100) .- 4\nz = sin.(x) + cos.(y)\n# Tricontour plot\ntricont(x, y, z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/tricont.jl\") # hide","category":"page"},{"location":"api/plotting/#Surface-plots","page":"Plotting functions","title":"Surface plots","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"surface","category":"page"},{"location":"api/plotting/#GRUtils.surface","page":"Plotting functions","title":"GRUtils.surface","text":"surface([x, y,] z; kwargs...)\n\nDraw a three-dimensional surface plot.\n\nEither a series of points or a two-dimensional array is drawn as a surface plot, colored according to the Z coordinates and the current colormap. It can receive one of the following:\n\nx values, y values and z values.\nM sorted values of the x axis, N sorted values of the y axis,   and a set of z values on a N×M grid.\nM sorted values of the x axis, N sorted values of the y axis,   and a callable to determine z values.\nz values on a N×M grid, with the x and y axes   defined as the indices of the columns and rows of the grid, respectively.\n\nIf a series of points is passed to this function, their values will be interpolated on a grid. For grid points outside the convex hull of the provided points, a value of 0 will be used.\n\nExamples\n\n# Create example grid data\nx = LinRange(-2, 2, 40)\ny = LinRange(0, pi, 20)\nz = sin.(x') .+ cos.(y)\n# Surface plot\nsurface(x, y, z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/surface.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"trisurf","category":"page"},{"location":"api/plotting/#GRUtils.trisurf","page":"Plotting functions","title":"GRUtils.trisurf","text":"tricont(x, y, z; kwargs...)\n\nDraw a triangular surface plot.\n\nEither a series of points or a two-dimensional array is drawn as a triangular surface plot. z values are interpolated between x and y values through Delaunay triangulation.\n\nnote: Note\nIf the series of points is concave, there may be interpolation artifacts on the edges of the plot, as the interpolation may occur in very acute triangles.\n\nExamples\n\n# Create example point data\nx = 8 .* rand(100) .- 4\ny = 8 .* rand(100) .- 4\nz = sin.(x) + cos.(y)\n# Tricontour plot\ntricont(x, y, z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/trisurf.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"wireframe","category":"page"},{"location":"api/plotting/#GRUtils.wireframe","page":"Plotting functions","title":"GRUtils.wireframe","text":"wireframe([x, y,] z; kwargs...)\n\nDraw a three-dimensional wireframe plot.\n\nEither a series of points or a two-dimensional array is drawn as a wireframe plot. It can receive one of the following:\n\nx values, y values and z values.\nM sorted values of the x axis, N sorted values of the y axis,   and a set of z values on a N×M grid.\nM sorted values of the x axis, N sorted values of the y axis,   and a callable to determine z values.\nz values on a N×M grid, with the x and y axes   defined as the indices of the columns and rows of the grid, respectively.\n\nAlso use the attributes color and linecolor to set the color of the surface and lines of the mesh, as RGB hexadecimal color values.\n\nIf a series of points is passed to this function, their values will be interpolated on a grid. For grid points outside the convex hull of the provided points, a value of 0 will be used.\n\nExamples\n\n# Create example grid data\nx = LinRange(-2, 2, 40)\ny = LinRange(0, pi, 20)\nz = sin.(x') .+ cos.(y)\n# Wireframe plot\nwireframe(x, y, z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/wireframe.jl\") # hide","category":"page"},{"location":"api/plotting/#Volume-rendering","page":"Plotting functions","title":"Volume rendering","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"volume","category":"page"},{"location":"api/plotting/#GRUtils.volume","page":"Plotting functions","title":"GRUtils.volume","text":"volume(v; kwargs...)\n\nDraw a the three-dimensional array v, using volume rendering.\n\nThe volume data is reduced to a two-dimensional image using an emission or absorption model, or by a maximum intensity projection. After the projection the current colormap is applied to the result.\n\nThe method to reduce volume data can be defined by the keyword argument algorithm –- a number or a string from the following table:\n\n# String description\n0 \"emission\" emission model (default)\n1 \"absorption\" absorption model\n2 \"mip\" maximum intensity projection\n\nExamples\n\n# Create example data\nx = LinRange(-1, 1, 40)\ny = LinRange(-1, 1, 40)\nz = LinRange(-1, 1, 40)\nv = 1 .- (x.^2 .+ y'.^2 .+ reshape(z,1,1,:).^2).^0.5 - 0.25 .* rand(40, 40, 40)\n# Draw the 3d volume data using an emission model\nvolume(v, algorithm=\"mip\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/volume.jl\") # hide","category":"page"},{"location":"api/plotting/#Heatmaps","page":"Plotting functions","title":"Heatmaps","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"heatmap","category":"page"},{"location":"api/plotting/#GRUtils.heatmap","page":"Plotting functions","title":"GRUtils.heatmap","text":"heatmap([x, y,] data; kwargs...)\n\nDraw a heatmap.\n\nThe current colormap is used to display a two-dimensional array data as a heatmap.\n\nIf data is an N×M array, the cells of the heatmap will be plotted in a grid of rectangular cells, whose edges are defined by the coordinates x (a sorted vector with M+1 values) and y (a sorted vector with N+1 values).\n\nIf x and y are not given, a uniform grid is drawn spanning the interval [1, M+1] in the X-axis, and [1, N+1] in the Y-axis.\n\nThe array is drawn with its first value in the bottom left corner, so in some cases it may be neccessary to flip the axes.\n\nBy default column and row indices are used for the x- and y-axes, respectively, so setting the axis limits is recommended. Also note that the values in the array must lie within the current z-axis limits so it may be neccessary to adjust these limits or clip the range of array values.\n\nExamples\n\n# Uniform heatmap on the left\nsubplot(1,2,1)\nx = LinRange(-2, 2, 40)\ny = LinRange(0, pi, 20)\nz = sin.(x') .+ cos.(y)\nheatmap(z)\n# Non uniform heatmap on the right\nsubplot(1,2,2)\nx = [0, 2, 3, 4.5, 5]\ny = [2, 3, 4.5, 5, 6, 8]\nz = rand(5, 4)\nheatmap(x, y, z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/heatmap.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"polarheatmap","category":"page"},{"location":"api/plotting/#GRUtils.polarheatmap","page":"Plotting functions","title":"GRUtils.polarheatmap","text":"polarheatmap(data; kwargs...)\n\nDraw a polar heatmap\n\nThe current colormap is used to display a two-dimensional array data as a polar heatmap.\n\nIf data is an N×M array, the cells of the matrix will be plotted in a circle divided in M angular sectors and N rings, such that the values of the first row will be concentrated in the center of the circle, and the following rows will be drawn in increasing concentric rings. The columns of the array are drawn as radii of the circle in a counterclockwise order, starting and ending in horizontal axis pointing to the right.\n\nExamples\n\n# Create example data\nangle = LinRange(0, 2π, 40)\nradius = LinRange(0, 10, 20)\nz = sin.(angle') .* cos.(radius)\npolarheatmap(z)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/polarheatmap.jl\") # hide","category":"page"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"shade","category":"page"},{"location":"api/plotting/#GRUtils.shade","page":"Plotting functions","title":"GRUtils.shade","text":"shade(x, y; kwargs...)\n\nDraw a point- or line-based heatmap.\n\nThe current colormap is used to display the footprint left by the pairs of x, y values. If the data contain NaN or missing, the footprints will be based on lines separated by those values. Otherwise the footprints will be based on points. The type of footprint can be enforced regardless of the input by the keyword argument footprint = \"lines\" or footprint = \"points\".\n\nThe value of that footprint is determined by a transformation that can be adjusted by the keyword argument xform –- a number or a string from the following table:\n\n# String description\n0 \"boolean\" boolean\n1 \"linear\" linear\n2 \"log\" logarithmic\n3 \"loglog\" double logarithmic\n4 \"cubic\" cubic\n5 \"equalized\" histogram equalized (default)\n\nExamples\n\n# Create line data with NaN as polyline separator\nx = [randn(10000); NaN; randn(10000) .+ 5 ]\ny = [randn(10000); NaN; randn(10000) .+ 5]\n# Draw shade\nshade(x, y, xform=\"loglog\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/shade.jl\") # hide","category":"page"},{"location":"api/plotting/#Images","page":"Plotting functions","title":"Images","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"imshow","category":"page"},{"location":"api/plotting/#GRUtils.imshow","page":"Plotting functions","title":"GRUtils.imshow","text":"imshow(img; kwargs...)\nimshow(img, (minval, maxval); kwargs...)\n\nDraw an image, defined by any of the following:\n\nA string with a valid file name of an image.\nA 3-dimensional H×W×C array, which will be drawn as an image W pixels wide and H pixels high, with C channels (3 or 4), corresponding to RGB or RGBA values between 0 and 1.\nA matrix of values, which will be drawn with a hue corresponding to their relative position in the current colormap. The range of values mapped in the colormap is by default [0, 1], but can be set to an arbitrary range between minval and maxval. Setting either limit to nothing will cause it to be automatically determined based on the data.\n\nExamples\n\n# Create an image\nx = LinRange(-3, 3, 150)\ny = LinRange(-2, 2, 100)\n# RGB values\nr = (1 .+ cos.(atan.(y, x')))/2\ng = (1 .+ sin.(atan.(y, x')))/2\nb = exp.(-(x'.^2 .+ y.^2)/4)\ndata = cat(r, g, b, dims=3)\n# Draw the image\nimshow(data)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/imshow.jl\") # hide","category":"page"},{"location":"api/plotting/#Isosurfaces","page":"Plotting functions","title":"Isosurfaces","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"isosurface","category":"page"},{"location":"api/plotting/#GRUtils.isosurface","page":"Plotting functions","title":"GRUtils.isosurface","text":"isosurface(data, isovalue; kwargs...)\n\nDraw an isosurface determined by the region of the three-dimensional array data around a given isovalue.\n\nThe isosurface is calculated so that values in data greater than isovalue are considered to be outside the surface, and the values lower than isovalue are inside the surface.\n\nThe color of the isosurface can be chosen with the keyword argument color, with the hexadecimal RGB color code.\n\nExamples\n\n# Create example data\ns = LinRange(-4, 4, 50)\nv = cos.(s) .+ cos.(s)' .+ cos.(reshape(s,1,1,:))\n# Draw the isosurface\nisosurface(v, 0.5, color=0x99ffcc)\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/isosurface.jl\") # hide","category":"page"},{"location":"api/plotting/#Text","page":"Plotting functions","title":"Text","text":"","category":"section"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"annotations","category":"page"},{"location":"api/plotting/#GRUtils.annotations","page":"Plotting functions","title":"GRUtils.annotations","text":"annotations(x, y, s)\n\nAdd one ore more text annotations to the current plot.\n\nx and y can be scalars or vectors of coordinates, and s a string or a vector of strings, respectively. Annotations are only available for 2-D plots.\n\nBy default the coordinates indicate the lower left corner of the text box. This can be changed by the following keyword arguments:\n\nhalign for the horizontal alignment (\"left\", \"center\" or \"right\").\nvalign for the vertical alignment (\"bottom\", \"center\" or \"top\").\n\nExamples\n\n# Create example data\nnumbers = [10, 15, 35, 20]\n# Plot bars with labels on top\nbarplot(numbers)\nannotations(1:4, numbers .+1 , string.(numbers), halign=\"center\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/plotting/","page":"Plotting functions","title":"Plotting functions","text":"Figure(); # hide\nBase.include(GRUtils, \"../examples/docstrings/annotations.jl\") # hide","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"using GRUtils, Random, Printf\nRandom.seed!(111)","category":"page"},{"location":"color/#Color-management","page":"Color management","title":"Color management","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"GRUtils uses various color sets for different purposes: color schemes for the general design of the plots, continuous colormaps to represent numeric data in a color scale, and a set of predefined colors with maximum contrast that are used to distinguish different data series in the same plot. Moreover, there is a space available for arbitrary user-defined colors based on RGB codes.","category":"page"},{"location":"color/#Color-scheme","page":"Color management","title":"Color scheme","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"Color schemes are based on a monochromatic scale between a \"foreground\" and a \"background\" color (e.g. black and white), and a set of basic or \"accent\" colors that approximate the six standard secondary colors: red, green, blue, cyan, yellow and magenta.","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"By default there are light and dark flavours of both standard and solarized schemes, whose background, foreground and the other basic colors can be seen below.","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"Figure((600,300)) # hide\ngeoms = [GRUtils.Geometry(:bar, x=[-2,-1], y=[-2,-1], # hide\n    color=GRUtils.switchbytes(UInt32(GRUtils.GR.inqcolor(i)))) # hide\n    for i ∈ GRUtils.BASIC_COLORS[3:end]] # hide\naxes = GRUtils.Axes(:axes2d, geoms, xlim=(0,1), ylim=(0,1), xticks=(0,0), yticks=(0,0)) # hide\nfor (s, schemename) in enumerate((\"LIGHT\", \"DARK\", \"SOLARIZED LIGHT\", \"SOLARIZED DARK\")) # hide\n    sp = subplot(2,2,s).attributes[:subplot] # hide\n    GRUtils.makeplot!(currentplot(), axes, geoms, subplot=sp, scheme=s) # hide\n    legend(\"red\",\"green\",\"blue\",\"cyan\",\"yellow\",\"magenta\", location=\"center\",maxrows=3) # hide\n    title(\"\\\\n$schemename\") # hide\nend # hide\ngcf() # hide","category":"page"},{"location":"color/#Colormaps","page":"Color management","title":"Colormaps","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"Colormaps are based on a scale of 256 contiguous colors that can be used to represent numeric ranges. GRUtils uses the \"Viridis\" colormap by default (see below), with the option of changing to any of the 48 built-in colormaps of GR.","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"Figure((600,200)) # hide\nim = ones(25) .* reshape(LinRange(0,1,256), 1, 256) # hide\nim = reshape(LinRange(0,1,256), 1, 256) # hide\nheatmap(im, colorbar=false, colormap=44, overlay_axes=true) # hide\nyticks(0,0) # hide\nxticks(25.6,1) # hide\nxticklabels(x -> Printf.@sprintf(\"%0.2f\", x/256)) # hide","category":"page"},{"location":"color/#High-contrast-color-set","page":"Color management","title":"High-contrast color set","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"When various geometries of the same kind are included in the same plot (e.g. line plots with multiple data series), they are drawn using the predefined sequence of colors that is shown below – unless a specific color is explicitly set by the user. That sequence has 20 different colors that approach Kelly’s list of colors with maximum contrast (leaving aside white and black), and the order of the first colors is reminiscent of the sequence used by GNU Octave or Matlab.","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"Figure((600, 150)) # hide\ngeoms = [GRUtils.Geometry(:bar, x=[-0.5,0.5] .+ i, y=[0,1], # hide\n    color=GRUtils.switchbytes( # hide\n        UInt32(GRUtils.GR.inqcolor(GRUtils.SERIES_COLORS[i])) # hide\n    )) # hide\n    for i = 1:20] # hide\naxes = GRUtils.Axes(:axes2d, geoms, # hide\n    xticks=(1,1), yticks=(0,0), # hide\n    xlim=(0.5,20.5) # hide\n) # hide\nGRUtils.makeplot!(currentplot(), axes, geoms) # hide\ngcf() # hide","category":"page"},{"location":"color/#User-defined-colors","page":"Color management","title":"User-defined colors","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"Custom colors can be defined as hexadecimal codes joining the values of 8-bit RGB channels. E.g. the number #FF6600 defines a bright orange color (R = #FF, G = #66, B = #00). Those codes can be defined directly as integer numbers, or from the RGB values normalized between 0 and 1, with the function color (unexported). For instance, the code #FF6600 can be defined in any of the following ways:","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"0xff6600                   # UInt32 number, equivalent to 16_737_792\nGRUtils.color(1, 0.4, 0)   # R = 1, G = 0.4, B= 0","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"warning: Warning\nThe RGB channels in those hexadecimal color codes are assumed to be \"word-ordered\" in a little-endian system, i.e. the red-green-blue bytes are ordered from the most to the least significant. Take care of the byte order if you use integer color codes calculated from other sources.","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"The color system of GR, used by GRUtils, has room for nearly 1,000 colors defined ad hoc by the user in each session – let aside the color sets that have already been commented. There are more than 16 million of possible RGB combinations, although in practice you will never need more than a small fraction of the space for user-defined colors.","category":"page"},{"location":"color/#Transparency","page":"Color management","title":"Transparency","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"By default, colors are assumed to be \"opaque\", but an alpha level of transparency can be added to user-defined colors: this is a value that can vary between 0 (fully transparent) and 1 (fully opaque).","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"Figure((600, 150)) # hide\ngeoms = [GRUtils.Geometry(:bar, x=[-0.5,0.5] .+ i, y=[0,1], # hide\n    color=0xcb3c33, alpha=1-(i-1)/10) for i = 1:11] # hide\naxes = GRUtils.Axes(:axes2d, geoms, # hide\n    xticks=(1,1), yticks=(0,0), # hide\n    xticklabels=x->repr(1-(x-1)/10, context=:compact=>true), #hide\n    xlim=(0.5,11.5), grid=false) # hide\nGRUtils.makeplot!(currentplot(), axes, geoms) # hide\ngcf() # hide","category":"page"},{"location":"color/#Using-colors-with-GRUtils","page":"Color management","title":"Using colors with GRUtils","text":"","category":"section"},{"location":"color/#General-scheme-and-color-map","page":"Color management","title":"General scheme and color map","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"The general color scheme and the colormap are set globally, but they can be changed at any time during the session with the functions colorscheme and colormap, or chosen specifically for particular plots with colorscheme! and colormap!. See the documentation of those functions for more details.","category":"page"},{"location":"color/#Color-of-geometries","page":"Color management","title":"Color of geometries","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"The high-contrast color set is managed automatically during the creation of plots, if no other colors are selected by the user. There are two ways to specify particular colors, depending on the kind of geometry:","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"Geometries based on lines and markers (e.g. in 2D or 3D line plots, among others), can receive a format string, as in matplotlib. Such strings may contain characters that correspond to the basic colors of the scheme:\n'r' for red,\n'g' for green,\n'b' for blue,\n'c' for cyan,\n'y' for yellow,\n'm' for magenta,\n'w' for the background color (white in the default scheme).\n'k' for the foreground color (black in the default scheme),\nMoreover, user-defined colors can be specified for the following attributes of some geometries:\nlinecolor for lines,\nmarkercolor for markers,\ncolor for filled areas in bars, isosurfaces, etc.","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"This can be done during the creation of the plots, as in the following examples:","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"Figure() # hide\n# Format string for a red line (straight)\nplot(LinRange(0, 1, 10), \"-r\")\nhold(true)\n# Add a purple line (curved)\nplot(exp.(LinRange(-1, 0, 10)),\n    linecolor=GRUtils.color(0.5, 0, 0.75))","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"The alpha channel of transparency can be also defined for all geometries using the keyword argument alpha, with any value between 0 and 1.","category":"page"},{"location":"color/#Background-colors","page":"Color management","title":"Background colors","text":"","category":"section"},{"location":"color/","page":"Color management","title":"Color management","text":"The background color of the areas that enclose the plot axes and legends is defined by the color scheme. By default, the outer area of the plots is either transparent or has the same background color, depending on the selected scheme (cf. colorscheme).","category":"page"},{"location":"color/","page":"Color management","title":"Color management","text":"The function background can be used to change the outer background of the figure, filling it with a user-defined color and a custom transparency level. This can be also done during the creation of the plot, using the keyword arguments backgroundcolor and backgroundalpha. This only affects the area outside the axes and legends.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = GRUtils","category":"page"},{"location":"#Introduction-to-GRUtils","page":"Introduction","title":"Introduction to GRUtils","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GRUtils is a refactoring of the module jlgr from GR, a graphics package for Julia. The purpose of GRUtils is to provide the main utilities of jlgr in a more \"Julian\" and modular style, easier to read, and facilitate code contributions by others.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GRUtils is being maintained in a package apart from GR, in order to make its development faster, assuming a temporary duplication of development efforts. Hopefully in a near future it will be clearer if the interface to GR provided in GRUtils deserves maintenance in such an independent \"plug-in\", or if its code should be integrated in GR itself.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Add GRUtils to your library of Julia packages, typing ] to enter in the \"package management mode\" and then typing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"add GRUtils","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Or if you feel like looking into GRUtils' code and maybe trying your own fixes and improvements, you can clone it for development (also in the package management mode):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dev GRUtils","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package depends on GR. If you don't have it installed before, GRUtils will install GR and its dependencies. Building GR ocassionally fails; so to ensure that everything will work, check the messages printed after the installation, and if there is some error related to \"Building GR\", retry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ENV[\"GRDIR\"] = \"\"\npkg> build GR","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(The julia> and pkg> tags do not have to be typed; they are there only to mark that the first instruction is in the normal REPL mode, and the second one in package management mode.)","category":"page"},{"location":"#A-basic-example","page":"Introduction","title":"A basic example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Let's see an example of a plot to start with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# Of course first you have to load the package\nusing GRUtils\nFigure(); # hide\n# Example data\nx = LinRange(0, 10, 500)\ny = sin.(x.^2) .* exp.(-x)\n# Making a line plot is as simple as this:\nplot(x, y)\n# Then hold the plot to add the envelope...\nhold(true)\n# The envelope is given in two columns,\n# plotted as dashed lines (\"--\") in black color (\"k\")\nplot(exp.(0:10).^-1 .* [1 -1], \"--k\")\n# Now set the Y-axis limits, and annotate the plot\nylim(-0.5, 0.5)\nlegend(\"signal\", \"envelope\")\nxlabel(\"X\")\nylabel(\"Y\")\ntitle(\"Example plot\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Depending on what environment you use (e.g. the Julia REPL, a Jupyter notebook, Atom or another IDE), this plot will be displayed in a different device (a plotting window, panel, a cell of the notebook...). If you want to keep it as an image file, use the function savefig, like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"savefig(\"example.svg\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The type of the file will be determined by the extension of the file. The list of available file types depends on the installed workstation, but common types (SVG, PNG, JGP, GIF, PS, PDF...) are usually supported.","category":"page"},{"location":"#Relationship-with-GR's-API","page":"Introduction","title":"Relationship with GR's API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Many more functions to make and manipulate plots are also available in GRUtils. Those functions have been designed to mimic the API of GR for Julia, so if you have been using GR before, you may use them mostly in the same way. These are the most remarkable differences:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The radius of polar plots always has its centre at zero, instead of the minimum value of the represented data.\nThe angle labels in polar and polarhistogram are by default in radians; and the bins of polarhistogram are by default positioned according to the values of the input.\nMatrices passed to imshow must contain numbers in the range [0, 1].\nThe function isosurface does not assume a default \"isovalue\", which has to be entered explicitly as second positional argument.\nStaircase plots (not present in GR's documentation) are made with the function stair instead of step, in order to avoid name conflicts with Base.step.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Some plots in GRUtils also allow extra features. Check the list of Plotting functions for more details.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"CurrentModule = GRUtils","category":"page"},{"location":"internals/extending/#Extending-GRUtils","page":"Extending GRUtils","title":"Extending GRUtils","text":"","category":"section"},{"location":"internals/extending/#Creation-of-new-plotting-functions","page":"Extending GRUtils","title":"Creation of new plotting functions","text":"","category":"section"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"One of the purposes of GRUtils' structure is to facilitate its extension through new kinds of plots. New functions to create plots based on existing geometries (e.g. through statistical transformation of the data) can be created with the @plotfunction macro and a custom function that sets up the data. Histograms are an example of this: they are a special kind of bar plots, where the position and heights of the bars are obtained from binning the input data. Now, the histogram functions are defined though something like this:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"@plotfunction(histogram, geom = :bar, axes = :axes2d, kind = :hist,\nsetargs = _setargs_hist, docstring = doc_hist)","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"The expressions used in that macro call are:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"histogram: the name of the function that will be created.\ngeom = :bar, to declare that the kind of the histogram geometries will be :bar.\naxes = :axes2d, to declare that it will be a plot drawn on 2-D axes.\nkind = :hist, an arbitrary option that helps to identify the kind of plot that will be made, although this is not currently used.\nsetargs = _setargs_hist: this is where the magic happens (see below). _setargs_hist is the name of a function that makes the transformation of the input data into the coordinates of the bars.\ndocstring = doc_hist: this is used to define the documentation string that will be associated to the plotting function (in this example contained in the variable doc_hist).\nkwargs (not used in this example): this should be a named tuple with extra keyword arguments that are passed to the constructors of geometries, axes and the plot object.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"The macro @plotfunction creates two functions, which in this example are:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"histogram(args...; kwargs...), a function that creates a histogram on the current plot of the current figure.\nhistogram!(fig, args...; kwargs...), which creates the histogram on the current plot of the figure given as fig.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"In the most simple cases, the input passed by the user to the new plotting function may be directly the variables that go straight to the x, y, etc. parameters of the geometries. But often (as in the case of histograms) it is not. In such case it is necessary to define the function that is identified by the setargs parameter in the macro. The signature of such a function must be:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"name_of_the_function(f::Figure, args...; kwargs...)","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"There args represents the set of positional arguments, and kwargs the keyword arguments that are passed by the user to the functions that are going to be created, and f is meant to be the figure where the plot will be placed. This \"set-up\" function can do whatever is needed with those arguments and the information of the figure, but it must return a tuple with two objects:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"A tuple with the positional arguments that will be passed to geometries to create the geometries of the plot.\nA named tuple containing keyword arguments needed by the different constructors (see the section Creating plots about that) to create the correct geometries, axes, etc.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"When the keyword arguments needed by the constructors are not determined by the input arguments, but they have fixed values for that kind of plot, it is more convenient to define them in the kwargs expression of the macro, instead of using the \"set-up\" function. But both approaches are equally valid.","category":"page"},{"location":"internals/extending/#Creation-of-new-geometries","page":"Extending GRUtils","title":"Creation of new geometries","text":"","category":"section"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"If the new kind of plot implies the definition of a new kind of geometry, other methods should be created in addition. Let's say that this new geometry is called mygeom; then at least the following method should be defined:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"draw(g::Geometry, ::Val{:mygeom})","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"This method should contain the low-level plotting instructions based on the functions of GR to draw the geometries (lines, markers, areas and other elements), using the data contained in g. The returned value should be nothing, unless the ends of the color scale are not given in the geometry g, but calculated by the functions of GR. In such case, this method can return a vector with the minimum and maximum values of the color scale (as Float64).","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"If the new geometry is also meant to have a legend key, its kind must be added to the constant LEGEND_KINDS, and the following method of the guide function should also be defined:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"guide(Val{:mygeom}, g, x, y)","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"This method should contain the plotting instructions to draw the key associated to the geometry g  in the (x, y coordinates). The dimensions of the key should not go outside a rectangular box centred in (0.0, 0.0), with width equal to 0.06 and height equal to 0.03, in NDC units.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"If the geometry also needs attributes that are not defined for other geometries (normally passed to the plotting function as keyword arguments), their name should also be added to the constant KEYS_GEOM_ATTRIBUTES in the first lines of frontend.jl.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"Take into account that the dictionary of geometry attributes only accepts Float64 numbers, so they should be coded as numbers. If from the user perspective it is more convenient to define them as other types, the function indicated by setargs may be used to transform the user-provided argument into a suitable number. (See _setargs_stair for an example of this.)","category":"page"},{"location":"internals/extending/#Extension-of-plot-attributes","page":"Extending GRUtils","title":"Extension of plot attributes","text":"","category":"section"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"The keyword arguments passed to the plotting functions are used to define particular characteristics of the geometries, axes, legends, colorbars and other elements of the plots. Often those characteristics must be part of the attributes parameter contained in the target PlotObject, because either:","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"They do not correspond to any parameter defined in the structure of other objects (as it is the case of the plot title, for instance).\nThey should be inherited by plots that are added to the PlotObject, when the hold attribute is set as true.","category":"page"},{"location":"internals/extending/","page":"Extending GRUtils","title":"Extending GRUtils","text":"Unlike the attributes of geometries, which must be numbers, the attributes of a PlotObject are stored in a Dict{Symbol, Any}, so any type of variable (numbers, strings, even functions) can be stored there. But the names of those attributes are also controlled by the constant KEY_PLOT_ATTRIBUTES defined in the first lines of frontend.jl. Therefore, if new attributes are defined for plots, it is important to add their names in that vector. Otherwise they will be ignored.","category":"page"}]
}
